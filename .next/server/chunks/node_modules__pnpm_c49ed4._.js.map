{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/run.js"],"sourcesContent":["/**\n * @typedef {import('mdx/types.js').MDXModule} MDXModule\n *\n * @typedef {import('./util/resolve-evaluate-options.js').RunOptions} RunOptions\n */\n\n/** @type {new (code: string, ...args: Array<unknown>) => Function} **/\nconst AsyncFunction = Object.getPrototypeOf(run).constructor\n\n/**\n * Run code compiled with `outputFormat: 'function-body'`.\n *\n * > ☢️ **Danger**: this `eval`s JavaScript.\n *\n * @param {{toString(): string}} code\n *   JavaScript function body to run.\n * @param {RunOptions} options\n *   Configuration (**required**).\n * @return {Promise<MDXModule>}\n *   Promise to a module;\n *   the result is an object with a `default` field set to the component;\n *   anything else that was exported is available too.\n */\nexport async function run(code, options) {\n  return new AsyncFunction(String(code))(options)\n}\n\n/**\n * Run code, synchronously.\n *\n * When possible please use the async `run`.\n *\n * > ☢️ **Danger**: this `eval`s JavaScript.\n *\n * @param {{toString(): string}} code\n *   JavaScript function body to run.\n * @param {RunOptions} options\n *   Configuration (**required**).\n * @return {MDXModule}\n *   Module.\n */\nexport function runSync(code, options) {\n  // eslint-disable-next-line no-new-func\n  return new Function(String(code))(options)\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED,qEAAqE;;;;AACrE,MAAM,gBAAgB,OAAO,cAAc,CAAC,KAAK,WAAW;AAgBrD,eAAe,IAAI,IAAI,EAAE,OAAO;IACrC,OAAO,IAAI,cAAc,OAAO,OAAO;AACzC;AAgBO,SAAS,QAAQ,IAAI,EAAE,OAAO;IACnC,uCAAuC;IACvC,OAAO,IAAI,SAAS,OAAO,OAAO;AACpC"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/node-types.js"],"sourcesContent":["/**\n * List of node types made by `mdast-util-mdx`, which have to be passed\n * through untouched from the mdast tree to the hast tree.\n */\nexport const nodeTypes = /** @type {const} */ ([\n  'mdxFlowExpression',\n  'mdxJsxFlowElement',\n  'mdxJsxTextElement',\n  'mdxTextExpression',\n  'mdxjsEsm'\n])\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AACM,MAAM,YAAkC;IAC7C;IACA;IACA;IACA;IACA;CACD"}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/plugin/remark-mark-and-unravel.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').RootContent} RootContent\n */\n\nimport {collapseWhiteSpace} from 'collapse-white-space'\nimport {visit} from 'unist-util-visit'\n\n/**\n * A tiny plugin that unravels `<p><h1>x</h1></p>` but also\n * `<p><Component /></p>` (so it has no knowledge of “HTML”).\n *\n * It also marks JSX as being explicitly JSX, so when a user passes a `h1`\n * component, it is used for `# heading` but not for `<h1>heading</h1>`.\n *\n * @returns\n *   Transform.\n */\nexport function remarkMarkAndUnravel() {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, function (node, index, parent) {\n      let offset = -1\n      let all = true\n      let oneOrMore = false\n\n      if (parent && typeof index === 'number' && node.type === 'paragraph') {\n        const children = node.children\n\n        while (++offset < children.length) {\n          const child = children[offset]\n\n          if (\n            child.type === 'mdxJsxTextElement' ||\n            child.type === 'mdxTextExpression'\n          ) {\n            oneOrMore = true\n          } else if (\n            child.type === 'text' &&\n            collapseWhiteSpace(child.value, {style: 'html', trim: true}) === ''\n          ) {\n            // Empty.\n          } else {\n            all = false\n            break\n          }\n        }\n\n        if (all && oneOrMore) {\n          offset = -1\n\n          /** @type {Array<RootContent>} */\n          const newChildren = []\n\n          while (++offset < children.length) {\n            const child = children[offset]\n\n            if (child.type === 'mdxJsxTextElement') {\n              // @ts-expect-error: mutate because it is faster; content model is fine.\n              child.type = 'mdxJsxFlowElement'\n            }\n\n            if (child.type === 'mdxTextExpression') {\n              // @ts-expect-error: mutate because it is faster; content model is fine.\n              child.type = 'mdxFlowExpression'\n            }\n\n            if (\n              child.type === 'text' &&\n              /^[\\t\\r\\n ]+$/.test(String(child.value))\n            ) {\n              // Empty.\n            } else {\n              newChildren.push(child)\n            }\n          }\n\n          parent.children.splice(index, 1, ...newChildren)\n          return index\n        }\n      }\n\n      if (\n        node.type === 'mdxJsxFlowElement' ||\n        node.type === 'mdxJsxTextElement'\n      ) {\n        const data = node.data || (node.data = {})\n        data._mdxExplicitJsx = true\n      }\n    })\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;AAeM,SAAS;IACd;;;;;GAKC,GACD,OAAO,SAAU,IAAI;QACnB,qNAAM,MAAM,SAAU,IAAI,EAAE,KAAK,EAAE,MAAM;YACvC,IAAI,SAAS,CAAC;YACd,IAAI,MAAM;YACV,IAAI,YAAY;YAEhB,IAAI,UAAU,OAAO,UAAU,YAAY,KAAK,IAAI,KAAK,aAAa;gBACpE,MAAM,WAAW,KAAK,QAAQ;gBAE9B,MAAO,EAAE,SAAS,SAAS,MAAM,CAAE;oBACjC,MAAM,QAAQ,QAAQ,CAAC,OAAO;oBAE9B,IACE,MAAM,IAAI,KAAK,uBACf,MAAM,IAAI,KAAK,qBACf;wBACA,YAAY;oBACd,OAAO,IACL,MAAM,IAAI,KAAK,UACf,0OAAmB,MAAM,KAAK,EAAE;wBAAC,OAAO;wBAAQ,MAAM;oBAAI,OAAO,IACjE;oBACA,SAAS;oBACX,OAAO;wBACL,MAAM;wBACN;oBACF;gBACF;gBAEA,IAAI,OAAO,WAAW;oBACpB,SAAS,CAAC;oBAEV,+BAA+B,GAC/B,MAAM,cAAc,EAAE;oBAEtB,MAAO,EAAE,SAAS,SAAS,MAAM,CAAE;wBACjC,MAAM,QAAQ,QAAQ,CAAC,OAAO;wBAE9B,IAAI,MAAM,IAAI,KAAK,qBAAqB;4BACtC,wEAAwE;4BACxE,MAAM,IAAI,GAAG;wBACf;wBAEA,IAAI,MAAM,IAAI,KAAK,qBAAqB;4BACtC,wEAAwE;4BACxE,MAAM,IAAI,GAAG;wBACf;wBAEA,IACE,MAAM,IAAI,KAAK,UACf,eAAe,IAAI,CAAC,OAAO,MAAM,KAAK,IACtC;wBACA,SAAS;wBACX,OAAO;4BACL,YAAY,IAAI,CAAC;wBACnB;oBACF;oBAEA,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO,MAAM;oBACpC,OAAO;gBACT;YACF;YAEA,IACE,KAAK,IAAI,KAAK,uBACd,KAAK,IAAI,KAAK,qBACd;gBACA,MAAM,OAAO,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC;gBACzC,KAAK,eAAe,GAAG;YACzB;QACF;IACF;AACF"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/plugin/rehype-remove-raw.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\n\n/**\n * A tiny plugin that removes raw HTML.\n *\n * This is needed if the format is `md` and `rehype-raw` was not used to parse\n * dangerous HTML into nodes.\n *\n * @returns\n *   Transform.\n */\nexport function rehypeRemoveRaw() {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, 'raw', function (_, index, parent) {\n      if (parent && typeof index === 'number') {\n        parent.children.splice(index, 1)\n        return index\n      }\n    })\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;AAaM,SAAS;IACd;;;;;GAKC,GACD,OAAO,SAAU,IAAI;QACnB,qNAAM,MAAM,OAAO,SAAU,CAAC,EAAE,KAAK,EAAE,MAAM;YAC3C,IAAI,UAAU,OAAO,UAAU,UAAU;gBACvC,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO;gBAC9B,OAAO;YACT;QACF;IACF;AACF"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/plugin/rehype-recma.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Program} Program\n *\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('../core.js').ProcessorOptions} ProcessorOptions\n */\n\nimport {toEstree} from 'hast-util-to-estree'\n\n/**\n * A plugin to transform an HTML (hast) tree to a JS (estree).\n * `hast-util-to-estree` does all the work for us!\n *\n * @param {Readonly<ProcessorOptions>} options\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport function rehypeRecma(options) {\n  /**\n   * @param {Root} tree\n   *   Tree (hast).\n   * @returns {Program}\n   *   Program (esast).\n   */\n  return function (tree) {\n    return toEstree(tree, options)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;AAaM,SAAS,YAAY,OAAO;IACjC;;;;;GAKC,GACD,OAAO,SAAU,IAAI;QACnB,OAAO,oOAAS,MAAM;IACxB;AACF"}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/plugin/recma-stringify.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('unified').Processor<undefined, undefined, undefined, Program, string>} Processor\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('../core.js').ProcessorOptions} ProcessorOptions\n */\n\nimport {jsx, toJs} from 'estree-util-to-js'\n\n/**\n * Serialize an esast (estree) program to JavaScript.\n *\n * @type {import('unified').Plugin<[Readonly<ProcessorOptions>], Program, string>}\n */\nexport function recmaStringify(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const {SourceMapGenerator} = options\n\n  self.compiler = compiler\n\n  /**\n   * @param {Program} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {string}\n   *   JavaScript.\n   */\n  function compiler(tree, file) {\n    const result = SourceMapGenerator\n      ? toJs(tree, {\n          SourceMapGenerator,\n          filePath: file.path || 'unknown.mdx',\n          handlers: jsx\n        })\n      : toJs(tree, {handlers: jsx})\n\n    file.map = result.map\n\n    return result.value\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;AASM,SAAS,eAAe,OAAO;IACpC,8CAA8C;IAC9C,sDAAsD;IACtD,MAAM,OAAiC,IAAI;IAC3C,MAAM,EAAC,kBAAkB,EAAC,GAAG;IAE7B,KAAK,QAAQ,GAAG;IAEhB;;;;;;;GAOC,GACD,SAAS,SAAS,IAAI,EAAE,IAAI;QAC1B,MAAM,SAAS,qBACX,4NAAK,MAAM;YACT;YACA,UAAU,KAAK,IAAI,IAAI;YACvB,QAAQ;QACV,KACA,4NAAK,MAAM;YAAC,QAAQ;QAAK;QAE7B,KAAK,GAAG,GAAG,OAAO,GAAG;QAErB,OAAO,OAAO,KAAK;IACrB;AACF"}},
    {"offset": {"line": 209, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/estree-util-to-id-or-member-expression.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n */\n\nimport {ok as assert} from 'devlop'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\n\n/**\n * @param {ReadonlyArray<number | string>} ids\n *   Identifiers (example: `['list', 0]).\n * @returns {Identifier | MemberExpression}\n *   Identifier or member expression.\n */\nexport function toIdOrMemberExpression(ids) {\n  let index = -1\n  /** @type {Identifier | Literal | MemberExpression | undefined} */\n  let object\n\n  while (++index < ids.length) {\n    const name = ids[index]\n    /** @type {Identifier | Literal} */\n    const id =\n      typeof name === 'string' && isIdentifierName(name)\n        ? {type: 'Identifier', name}\n        : {type: 'Literal', value: name}\n    object = object\n      ? {\n          type: 'MemberExpression',\n          object,\n          property: id,\n          computed: id.type === 'Literal',\n          optional: false\n        }\n      : id\n  }\n\n  assert(object, 'expected non-empty `ids` to be passed')\n  assert(object.type !== 'Literal', 'expected identifier as left-most value')\n  return object\n}\n\n/**\n * @param {ReadonlyArray<number | string>} ids\n *   Identifiers (example: `['list', 0]).\n * @returns {JSXIdentifier | JSXMemberExpression}\n *   Identifier or member expression.\n */\nexport function toJsxIdOrMemberExpression(ids) {\n  let index = -1\n  /** @type {JSXIdentifier | JSXMemberExpression | undefined} */\n  let object\n\n  while (++index < ids.length) {\n    const name = ids[index]\n    assert(\n      typeof name === 'string' && isIdentifierName(name, {jsx: true}),\n      'expected valid jsx identifier, not `' + name + '`'\n    )\n\n    /** @type {JSXIdentifier} */\n    const id = {type: 'JSXIdentifier', name}\n    object = object ? {type: 'JSXMemberExpression', object, property: id} : id\n  }\n\n  assert(object, 'expected non-empty `ids` to be passed')\n  return object\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;AAWM,SAAS,uBAAuB,GAAG;IACxC,IAAI,QAAQ,CAAC;IACb,gEAAgE,GAChE,IAAI;IAEJ,MAAO,EAAE,QAAQ,IAAI,MAAM,CAAE;QAC3B,MAAM,OAAO,GAAG,CAAC,MAAM;QACvB,iCAAiC,GACjC,MAAM,KACJ,OAAO,SAAS,YAAY,4PAAiB,QACzC;YAAC,MAAM;YAAc;QAAI,IACzB;YAAC,MAAM;YAAW,OAAO;QAAI;QACnC,SAAS,SACL;YACE,MAAM;YACN;YACA,UAAU;YACV,UAAU,GAAG,IAAI,KAAK;YACtB,UAAU;QACZ,IACA;IACN;IAEA,+LAAO,QAAQ;IACf,+LAAO,OAAO,IAAI,KAAK,WAAW;IAClC,OAAO;AACT;AAQO,SAAS,0BAA0B,GAAG;IAC3C,IAAI,QAAQ,CAAC;IACb,4DAA4D,GAC5D,IAAI;IAEJ,MAAO,EAAE,QAAQ,IAAI,MAAM,CAAE;QAC3B,MAAM,OAAO,GAAG,CAAC,MAAM;QACvB,+LACE,OAAO,SAAS,YAAY,4PAAiB,MAAM;YAAC,KAAK;QAAI,IAC7D,yCAAyC,OAAO;QAGlD,0BAA0B,GAC1B,MAAM,KAAK;YAAC,MAAM;YAAiB;QAAI;QACvC,SAAS,SAAS;YAAC,MAAM;YAAuB;YAAQ,UAAU;QAAE,IAAI;IAC1E;IAEA,+LAAO,QAAQ;IACf,OAAO;AACT"}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 279, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/estree-util-to-binary-addition.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Expression} Expression\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * @param {ReadonlyArray<Expression>} expressions\n *   Expressions.\n * @returns {Expression}\n *   Addition.\n */\nexport function toBinaryAddition(expressions) {\n  let index = -1\n  /** @type {Expression | undefined} */\n  let left\n\n  while (++index < expressions.length) {\n    const right = expressions[index]\n    left = left ? {type: 'BinaryExpression', left, operator: '+', right} : right\n  }\n\n  assert(left, 'expected non-empty `expressions` to be passed')\n  return left\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;AAUM,SAAS,iBAAiB,WAAW;IAC1C,IAAI,QAAQ,CAAC;IACb,mCAAmC,GACnC,IAAI;IAEJ,MAAO,EAAE,QAAQ,YAAY,MAAM,CAAE;QACnC,MAAM,QAAQ,WAAW,CAAC,MAAM;QAChC,OAAO,OAAO;YAAC,MAAM;YAAoB;YAAM,UAAU;YAAK;QAAK,IAAI;IACzE;IAEA,+LAAO,MAAM;IACb,OAAO;AACT"}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/estree-util-create.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Node} Node\n */\n\n// Fix to show references to above types in VS Code.\n''\n\n/**\n * @param {Readonly<Node>} from\n *   Node to take from.\n * @param {Node} to\n *   Node to add to.\n * @returns {undefined}\n *   Nothing.\n */\nexport function create(from, to) {\n  /** @type {Array<keyof Node>} */\n  // @ts-expect-error: `start`, `end`, `comments` are custom Acorn fields.\n  const fields = ['start', 'end', 'loc', 'range', 'comments']\n  let index = -1\n\n  while (++index < fields.length) {\n    const field = fields[index]\n\n    if (field in from) {\n      // @ts-expect-error: assume they’re settable.\n      to[field] = from[field]\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED,oDAAoD;;;;AACpD;AAUO,SAAS,OAAO,IAAI,EAAE,EAAE;IAC7B,8BAA8B,GAC9B,wEAAwE;IACxE,MAAM,SAAS;QAAC;QAAS;QAAO;QAAO;QAAS;KAAW;IAC3D,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,OAAO,MAAM,CAAE;QAC9B,MAAM,QAAQ,MAAM,CAAC,MAAM;QAE3B,IAAI,SAAS,MAAM;YACjB,6CAA6C;YAC7C,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM;QACzB;IACF;AACF"}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/estree-util-specifiers-to-declarations.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').AssignmentProperty} AssignmentProperty\n * @typedef {import('estree-jsx').ExportSpecifier} ExportSpecifier\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportDefaultSpecifier} ImportDefaultSpecifier\n * @typedef {import('estree-jsx').ImportNamespaceSpecifier} ImportNamespaceSpecifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').VariableDeclarator} VariableDeclarator\n */\n\nimport {create} from './estree-util-create.js'\n\n/**\n * @param {ReadonlyArray<Readonly<ExportSpecifier> | Readonly<ImportDefaultSpecifier> | Readonly<ImportNamespaceSpecifier> | Readonly<ImportSpecifier>>} specifiers\n *   Specifiers.\n * @param {Readonly<Expression>} init\n *   Initializer.\n * @returns {Array<VariableDeclarator>}\n *   Declarations.\n */\nexport function specifiersToDeclarations(specifiers, init) {\n  let index = -1\n  /** @type {Array<VariableDeclarator>} */\n  const declarations = []\n  /** @type {Array<ExportSpecifier | ImportDefaultSpecifier | ImportSpecifier>} */\n  const otherSpecifiers = []\n  // Can only be one according to JS syntax.\n  /** @type {ImportNamespaceSpecifier | undefined} */\n  let importNamespaceSpecifier\n\n  while (++index < specifiers.length) {\n    const specifier = specifiers[index]\n\n    if (specifier.type === 'ImportNamespaceSpecifier') {\n      importNamespaceSpecifier = specifier\n    } else {\n      otherSpecifiers.push(specifier)\n    }\n  }\n\n  if (importNamespaceSpecifier) {\n    /** @type {VariableDeclarator} */\n    const declarator = {\n      type: 'VariableDeclarator',\n      id: importNamespaceSpecifier.local,\n      init\n    }\n    create(importNamespaceSpecifier, declarator)\n    declarations.push(declarator)\n  }\n\n  declarations.push({\n    type: 'VariableDeclarator',\n    id: {\n      type: 'ObjectPattern',\n      properties: otherSpecifiers.map(function (specifier) {\n        /** @type {Identifier} */\n        let key =\n          specifier.type === 'ImportSpecifier'\n            ? specifier.imported\n            : specifier.type === 'ExportSpecifier'\n            ? specifier.exported\n            : {type: 'Identifier', name: 'default'}\n        let value = specifier.local\n\n        // Switch them around if we’re exporting.\n        if (specifier.type === 'ExportSpecifier') {\n          value = key\n          key = specifier.local\n        }\n\n        /** @type {AssignmentProperty} */\n        const property = {\n          type: 'Property',\n          kind: 'init',\n          shorthand: key.name === value.name,\n          method: false,\n          computed: false,\n          key,\n          value\n        }\n        create(specifier, property)\n        return property\n      })\n    },\n    init: importNamespaceSpecifier\n      ? {type: 'Identifier', name: importNamespaceSpecifier.local.name}\n      : init\n  })\n\n  return declarations\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AAYM,SAAS,yBAAyB,UAAU,EAAE,IAAI;IACvD,IAAI,QAAQ,CAAC;IACb,sCAAsC,GACtC,MAAM,eAAe,EAAE;IACvB,8EAA8E,GAC9E,MAAM,kBAAkB,EAAE;IAC1B,0CAA0C;IAC1C,iDAAiD,GACjD,IAAI;IAEJ,MAAO,EAAE,QAAQ,WAAW,MAAM,CAAE;QAClC,MAAM,YAAY,UAAU,CAAC,MAAM;QAEnC,IAAI,UAAU,IAAI,KAAK,4BAA4B;YACjD,2BAA2B;QAC7B,OAAO;YACL,gBAAgB,IAAI,CAAC;QACvB;IACF;IAEA,IAAI,0BAA0B;QAC5B,+BAA+B,GAC/B,MAAM,aAAa;YACjB,MAAM;YACN,IAAI,yBAAyB,KAAK;YAClC;QACF;QACA,gPAAO,0BAA0B;QACjC,aAAa,IAAI,CAAC;IACpB;IAEA,aAAa,IAAI,CAAC;QAChB,MAAM;QACN,IAAI;YACF,MAAM;YACN,YAAY,gBAAgB,GAAG,CAAC,SAAU,SAAS;gBACjD,uBAAuB,GACvB,IAAI,MACF,UAAU,IAAI,KAAK,oBACf,UAAU,QAAQ,GAClB,UAAU,IAAI,KAAK,oBACnB,UAAU,QAAQ,GAClB;oBAAC,MAAM;oBAAc,MAAM;gBAAS;gBAC1C,IAAI,QAAQ,UAAU,KAAK;gBAE3B,yCAAyC;gBACzC,IAAI,UAAU,IAAI,KAAK,mBAAmB;oBACxC,QAAQ;oBACR,MAAM,UAAU,KAAK;gBACvB;gBAEA,+BAA+B,GAC/B,MAAM,WAAW;oBACf,MAAM;oBACN,MAAM;oBACN,WAAW,IAAI,IAAI,KAAK,MAAM,IAAI;oBAClC,QAAQ;oBACR,UAAU;oBACV;oBACA;gBACF;gBACA,gPAAO,WAAW;gBAClB,OAAO;YACT;QACF;QACA,MAAM,2BACF;YAAC,MAAM;YAAc,MAAM,yBAAyB,KAAK,CAAC,IAAI;QAAA,IAC9D;IACN;IAEA,OAAO;AACT"}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/plugin/recma-jsx-rewrite.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Function} EstreeFunction\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXElement} JSXElement\n * @typedef {import('estree-jsx').ModuleDeclaration} ModuleDeclaration\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectPattern} ObjectPattern\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n * @typedef {import('estree-jsx').Statement} Statement\n * @typedef {import('estree-jsx').VariableDeclarator} VariableDeclarator\n *\n * @typedef {import('periscopic').Scope} PeriscopicScope\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('../core.js').ProcessorOptions} ProcessorOptions\n */\n\n/**\n * @typedef {PeriscopicScope & {node: Node}} Scope\n *   Scope (with a `node`).\n *\n * @typedef StackEntry\n *   Entry.\n * @property {Array<string>} components\n *   Used components.\n * @property {Map<string, string>} idToInvalidComponentName\n *   Map of JSX identifiers which cannot be used as JS identifiers, to valid JS identifiers.\n * @property {Readonly<EstreeFunction>} node\n *   Function.\n * @property {Array<string>} objects\n *   Identifiers of used objects (such as `x` in `x.y`).\n * @property {Record<string, {node: Readonly<JSXElement>, component: boolean}>} references\n *   Map of JSX identifiers for components and objects, to where they were first used.\n * @property {Array<string>} tags\n *   Tag names.\n */\n\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {walk} from 'estree-walker'\nimport {analyze} from 'periscopic'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nimport {positionFromEstree} from 'unist-util-position-from-estree'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {toBinaryAddition} from '../util/estree-util-to-binary-addition.js'\nimport {\n  toIdOrMemberExpression,\n  toJsxIdOrMemberExpression\n} from '../util/estree-util-to-id-or-member-expression.js'\n\n/**\n * A plugin that rewrites JSX in functions to accept components as\n * `props.components` (when the function is called `_createMdxContent`), or from\n * a provider (if there is one).\n * It also makes sure that any undefined components are defined: either from\n * received components or as a function that throws an error.\n *\n * @param {Readonly<ProcessorOptions>} options\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport function recmaJsxRewrite(options) {\n  const {development, outputFormat, providerImportSource} = options\n\n  /**\n   * @param {Program} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    // Find everything that’s defined in the top-level scope.\n    const scopeInfo = analyze(tree)\n    /** @type {Array<StackEntry>} */\n    const fnStack = []\n    let importProvider = false\n    let createErrorHelper = false\n    /** @type {Scope | undefined} */\n    let currentScope\n\n    walk(tree, {\n      enter(node) {\n        // Cast because we match `node`.\n        const newScope = /** @type {Scope | undefined} */ (\n          scopeInfo.map.get(node)\n        )\n\n        if (\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression' ||\n          node.type === 'ArrowFunctionExpression'\n        ) {\n          fnStack.push({\n            components: [],\n            idToInvalidComponentName: new Map(),\n            node,\n            objects: [],\n            references: {},\n            tags: []\n          })\n\n          // MDXContent only ever contains MDXLayout\n          if (\n            isNamedFunction(node, 'MDXContent') &&\n            newScope &&\n            !inScope(newScope, 'MDXLayout')\n          ) {\n            fnStack[0].components.push('MDXLayout')\n          }\n        }\n\n        const fnScope = fnStack[0]\n        if (\n          !fnScope ||\n          (!isNamedFunction(fnScope.node, '_createMdxContent') &&\n            !providerImportSource)\n        ) {\n          return\n        }\n\n        if (newScope) {\n          newScope.node = node\n          currentScope = newScope\n        }\n\n        if (currentScope && node.type === 'JSXElement') {\n          let name = node.openingElement.name\n\n          // `<x.y>`, `<Foo.Bar>`, `<x.y.z>`.\n          if (name.type === 'JSXMemberExpression') {\n            /** @type {Array<string>} */\n            const ids = []\n\n            // Find the left-most identifier.\n            while (name.type === 'JSXMemberExpression') {\n              ids.unshift(name.property.name)\n              name = name.object\n            }\n\n            ids.unshift(name.name)\n            const fullId = ids.join('.')\n            const id = name.name\n\n            const isInScope = inScope(currentScope, id)\n\n            if (!Object.hasOwn(fnScope.references, fullId)) {\n              // Cast because we match `node`.\n              const parentScope = /** @type {Scope | undefined} */ (\n                currentScope.parent\n              )\n              if (\n                !isInScope ||\n                // If the parent scope is `_createMdxContent`, then this\n                // references a component we can add a check statement for.\n                (parentScope &&\n                  parentScope.node.type === 'FunctionDeclaration' &&\n                  isNamedFunction(parentScope.node, '_createMdxContent'))\n              ) {\n                fnScope.references[fullId] = {component: true, node}\n              }\n            }\n\n            if (!fnScope.objects.includes(id) && !isInScope) {\n              fnScope.objects.push(id)\n            }\n          }\n          // `<xml:thing>`.\n          else if (name.type === 'JSXNamespacedName') {\n            // Ignore namespaces.\n          }\n          // If the name is a valid ES identifier, and it doesn’t start with a\n          // lowercase letter, it’s a component.\n          // For example, `$foo`, `_bar`, `Baz` are all component names.\n          // But `foo` and `b-ar` are tag names.\n          else if (isIdentifierName(name.name) && !/^[a-z]/.test(name.name)) {\n            const id = name.name\n\n            if (!inScope(currentScope, id)) {\n              // No need to add an error for an undefined layout — we use an\n              // `if` later.\n              if (\n                id !== 'MDXLayout' &&\n                !Object.hasOwn(fnScope.references, id)\n              ) {\n                fnScope.references[id] = {component: true, node}\n              }\n\n              if (!fnScope.components.includes(id)) {\n                fnScope.components.push(id)\n              }\n            }\n          } else if (node.data && node.data._mdxExplicitJsx) {\n            // Do not turn explicit JSX into components from `_components`.\n            // As in, a given `h1` component is used for `# heading` (next case),\n            // but not for `<h1>heading</h1>`.\n          } else {\n            const id = name.name\n\n            if (!fnScope.tags.includes(id)) {\n              fnScope.tags.push(id)\n            }\n\n            /** @type {Array<number | string>} */\n            let jsxIdExpression = ['_components', id]\n            if (isIdentifierName(id) === false) {\n              let invalidComponentName =\n                fnScope.idToInvalidComponentName.get(id)\n              if (invalidComponentName === undefined) {\n                invalidComponentName = `_component${fnScope.idToInvalidComponentName.size}`\n                fnScope.idToInvalidComponentName.set(id, invalidComponentName)\n              }\n\n              jsxIdExpression = [invalidComponentName]\n            }\n\n            node.openingElement.name =\n              toJsxIdOrMemberExpression(jsxIdExpression)\n\n            if (node.closingElement) {\n              node.closingElement.name =\n                toJsxIdOrMemberExpression(jsxIdExpression)\n            }\n          }\n        }\n      },\n      leave(node) {\n        /** @type {Array<Property | SpreadElement>} */\n        const defaults = []\n        /** @type {Array<string>} */\n        const actual = []\n        /** @type {Array<Expression>} */\n        const parameters = []\n        /** @type {Array<VariableDeclarator>} */\n        const declarations = []\n\n        if (currentScope && currentScope.node === node) {\n          // Cast to patch our `node`.\n          currentScope = /** @type {Scope} */ (currentScope.parent)\n        }\n\n        if (\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression' ||\n          node.type === 'ArrowFunctionExpression'\n        ) {\n          const fn = node\n          const scope = fnStack[fnStack.length - 1]\n          /** @type {string} */\n          let name\n\n          for (name of scope.tags.sort()) {\n            defaults.push({\n              type: 'Property',\n              kind: 'init',\n              key: isIdentifierName(name)\n                ? {type: 'Identifier', name}\n                : {type: 'Literal', value: name},\n              value: {type: 'Literal', value: name},\n              method: false,\n              shorthand: false,\n              computed: false\n            })\n          }\n\n          actual.push(...scope.components)\n\n          for (name of scope.objects) {\n            // In some cases, a component is used directly (`<X>`) but it’s also\n            // used as an object (`<X.Y>`).\n            if (!actual.includes(name)) {\n              actual.push(name)\n            }\n          }\n\n          actual.sort()\n\n          /** @type {Array<Statement>} */\n          const statements = []\n\n          if (\n            defaults.length > 0 ||\n            actual.length > 0 ||\n            scope.idToInvalidComponentName.size > 0\n          ) {\n            if (providerImportSource) {\n              importProvider = true\n              parameters.push({\n                type: 'CallExpression',\n                callee: {type: 'Identifier', name: '_provideComponents'},\n                arguments: [],\n                optional: false\n              })\n            }\n\n            // Accept `components` as a prop if this is the `MDXContent` or\n            // `_createMdxContent` function.\n            if (\n              isNamedFunction(scope.node, 'MDXContent') ||\n              isNamedFunction(scope.node, '_createMdxContent')\n            ) {\n              parameters.push(toIdOrMemberExpression(['props', 'components']))\n            }\n\n            if (defaults.length > 0 || parameters.length > 1) {\n              for (const parameter of parameters) {\n                defaults.push({type: 'SpreadElement', argument: parameter})\n              }\n            }\n\n            // If we’re getting components from several sources, merge them.\n            /** @type {Expression} */\n            let componentsInit =\n              defaults.length > 0\n                ? {type: 'ObjectExpression', properties: defaults}\n                : // If we’re only getting components from `props.components`,\n                  // make sure it’s defined.\n                  {\n                    type: 'LogicalExpression',\n                    operator: '||',\n                    left: parameters[0],\n                    right: {type: 'ObjectExpression', properties: []}\n                  }\n\n            /** @type {ObjectPattern | undefined} */\n            let componentsPattern\n\n            // Add components to scope.\n            // For `['MyComponent', 'MDXLayout']` this generates:\n            // ```tsx\n            // const {MyComponent, wrapper: MDXLayout} = _components\n            // ```\n            // Note that MDXLayout is special as it’s taken from\n            // `_components.wrapper`.\n            if (actual.length > 0) {\n              componentsPattern = {\n                type: 'ObjectPattern',\n                properties: actual.map(function (name) {\n                  return {\n                    type: 'Property',\n                    kind: 'init',\n                    key: {\n                      type: 'Identifier',\n                      name: name === 'MDXLayout' ? 'wrapper' : name\n                    },\n                    value: {type: 'Identifier', name},\n                    method: false,\n                    shorthand: name !== 'MDXLayout',\n                    computed: false\n                  }\n                })\n              }\n            }\n\n            if (scope.tags.length > 0) {\n              declarations.push({\n                type: 'VariableDeclarator',\n                id: {type: 'Identifier', name: '_components'},\n                init: componentsInit\n              })\n              componentsInit = {type: 'Identifier', name: '_components'}\n            }\n\n            if (isNamedFunction(scope.node, '_createMdxContent')) {\n              for (const [id, componentName] of [\n                ...scope.idToInvalidComponentName\n              ].sort(function ([a], [b]) {\n                return a.localeCompare(b)\n              })) {\n                // For JSX IDs that can’t be represented as JavaScript IDs (as in,\n                // those with dashes, such as `custom-element`), generate a\n                // separate variable that is a valid JS ID (such as `_component0`),\n                // and takes it from components:\n                // `const _component0 = _components['custom-element']`\n                declarations.push({\n                  type: 'VariableDeclarator',\n                  id: {\n                    type: 'Identifier',\n                    name: componentName\n                  },\n                  init: {\n                    type: 'MemberExpression',\n                    object: {type: 'Identifier', name: '_components'},\n                    property: {type: 'Literal', value: id},\n                    computed: true,\n                    optional: false\n                  }\n                })\n              }\n            }\n\n            if (componentsPattern) {\n              declarations.push({\n                type: 'VariableDeclarator',\n                id: componentsPattern,\n                init: componentsInit\n              })\n            }\n\n            if (declarations.length > 0) {\n              statements.push({\n                type: 'VariableDeclaration',\n                kind: 'const',\n                declarations\n              })\n            }\n          }\n\n          /** @type {string} */\n          let key\n\n          // Add partials (so for `x.y.z` it’d generate `x` and `x.y` too).\n          for (key in scope.references) {\n            if (Object.hasOwn(scope.references, key)) {\n              const parts = key.split('.')\n              let index = 0\n              while (++index < parts.length) {\n                const partial = parts.slice(0, index).join('.')\n                if (!Object.hasOwn(scope.references, partial)) {\n                  scope.references[partial] = {\n                    component: false,\n                    node: scope.references[key].node\n                  }\n                }\n              }\n            }\n          }\n\n          const references = Object.keys(scope.references).sort()\n          let index = -1\n          while (++index < references.length) {\n            const id = references[index]\n            const info = scope.references[id]\n            const place = stringifyPosition(positionFromEstree(info.node))\n            /** @type {Array<Expression>} */\n            const parameters = [\n              {type: 'Literal', value: id},\n              {type: 'Literal', value: info.component}\n            ]\n\n            createErrorHelper = true\n\n            if (development && place) {\n              parameters.push({type: 'Literal', value: place})\n            }\n\n            statements.push({\n              type: 'IfStatement',\n              test: {\n                type: 'UnaryExpression',\n                operator: '!',\n                prefix: true,\n                argument: toIdOrMemberExpression(id.split('.'))\n              },\n              consequent: {\n                type: 'ExpressionStatement',\n                expression: {\n                  type: 'CallExpression',\n                  callee: {type: 'Identifier', name: '_missingMdxReference'},\n                  arguments: parameters,\n                  optional: false\n                }\n              },\n              alternate: undefined\n            })\n          }\n\n          if (statements.length > 0) {\n            // Arrow functions with an implied return:\n            if (fn.body.type !== 'BlockStatement') {\n              fn.body = {\n                type: 'BlockStatement',\n                body: [{type: 'ReturnStatement', argument: fn.body}]\n              }\n            }\n\n            fn.body.body.unshift(...statements)\n          }\n\n          fnStack.pop()\n        }\n      }\n    })\n\n    // If a provider is used (and can be used), import it.\n    if (importProvider && providerImportSource) {\n      tree.body.unshift(\n        createImportProvider(providerImportSource, outputFormat)\n      )\n    }\n\n    // If potentially missing components are used.\n    if (createErrorHelper) {\n      /** @type {Array<Expression>} */\n      const message = [\n        {type: 'Literal', value: 'Expected '},\n        {\n          type: 'ConditionalExpression',\n          test: {type: 'Identifier', name: 'component'},\n          consequent: {type: 'Literal', value: 'component'},\n          alternate: {type: 'Literal', value: 'object'}\n        },\n        {type: 'Literal', value: ' `'},\n        {type: 'Identifier', name: 'id'},\n        {\n          type: 'Literal',\n          value:\n            '` to be defined: you likely forgot to import, pass, or provide it.'\n        }\n      ]\n\n      /** @type {Array<Identifier>} */\n      const parameters = [\n        {type: 'Identifier', name: 'id'},\n        {type: 'Identifier', name: 'component'}\n      ]\n\n      if (development) {\n        message.push({\n          type: 'ConditionalExpression',\n          test: {type: 'Identifier', name: 'place'},\n          consequent: toBinaryAddition([\n            {type: 'Literal', value: '\\nIt’s referenced in your code at `'},\n            {type: 'Identifier', name: 'place'},\n            {\n              type: 'Literal',\n              value: (file.path ? '` in `' + file.path : '') + '`'\n            }\n          ]),\n          alternate: {type: 'Literal', value: ''}\n        })\n\n        parameters.push({type: 'Identifier', name: 'place'})\n      }\n\n      tree.body.push({\n        type: 'FunctionDeclaration',\n        id: {type: 'Identifier', name: '_missingMdxReference'},\n        generator: false,\n        async: false,\n        params: parameters,\n        body: {\n          type: 'BlockStatement',\n          body: [\n            {\n              type: 'ThrowStatement',\n              argument: {\n                type: 'NewExpression',\n                callee: {type: 'Identifier', name: 'Error'},\n                arguments: [toBinaryAddition(message)]\n              }\n            }\n          ]\n        }\n      })\n    }\n\n    if (outputFormat === 'function-body') {\n      tree.body.unshift({\n        type: 'ExpressionStatement',\n        expression: {type: 'Literal', value: 'use strict'},\n        directive: 'use strict'\n      })\n    }\n  }\n}\n\n/**\n * @param {string} providerImportSource\n *   Provider source.\n * @param {'function-body' | 'program' | null | undefined} outputFormat\n *   Format.\n * @returns {ModuleDeclaration | Statement}\n *   Node.\n */\nfunction createImportProvider(providerImportSource, outputFormat) {\n  /** @type {Array<ImportSpecifier>} */\n  const specifiers = [\n    {\n      type: 'ImportSpecifier',\n      imported: {type: 'Identifier', name: 'useMDXComponents'},\n      local: {type: 'Identifier', name: '_provideComponents'}\n    }\n  ]\n\n  return outputFormat === 'function-body'\n    ? {\n        type: 'VariableDeclaration',\n        kind: 'const',\n        declarations: specifiersToDeclarations(\n          specifiers,\n          toIdOrMemberExpression(['arguments', 0])\n        )\n      }\n    : {\n        type: 'ImportDeclaration',\n        specifiers,\n        source: {type: 'Literal', value: providerImportSource}\n      }\n}\n\n/**\n * @param {Readonly<EstreeFunction>} node\n *   Node.\n * @param {string} name\n *   Name.\n * @returns {boolean}\n *   Whether `node` is a named function with `name`.\n */\nfunction isNamedFunction(node, name) {\n  return Boolean(node && 'id' in node && node.id && node.id.name === name)\n}\n\n/**\n * @param {Readonly<Scope>} scope\n *   Scope.\n * @param {string} id\n *   Identifier.\n * @returns {boolean}\n *   Whether `id` is in `scope`.\n */\nfunction inScope(scope, id) {\n  /** @type {Scope | undefined} */\n  let currentScope = scope\n\n  while (currentScope) {\n    if (currentScope.declarations.has(id)) {\n      return true\n    }\n\n    // Cast to patch our `node`.\n    currentScope = /** @type {Scope | undefined} */ (\n      currentScope.parent || undefined\n    )\n  }\n\n  return false\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1035, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1040, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/plugin/recma-jsx-build.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('estree-util-build-jsx').Options} BuildJsxOptions\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef ExtraOptions\n *   Configuration for internal plugin `recma-jsx-build`.\n * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']\n *   Whether to keep the import of the automatic runtime or get it from\n *   `arguments[0]` instead (default: `'program'`).\n *\n * @typedef {BuildJsxOptions & ExtraOptions} Options\n *   Options.\n */\n\nimport {buildJsx} from 'estree-util-build-jsx'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {toIdOrMemberExpression} from '../util/estree-util-to-id-or-member-expression.js'\n\n/**\n * A plugin to build JSX into function calls.\n * `estree-util-build-jsx` does all the work for us!\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport function recmaJsxBuild(options) {\n  /* c8 ignore next -- always given in `@mdx-js/mdx` */\n  const {development, outputFormat} = options || {}\n\n  /**\n   * @param {Program} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    buildJsx(tree, {development, filePath: file.history[0]})\n\n    // Remove the pragma comment that we injected ourselves as it is no longer\n    // needed.\n    if (\n      tree.comments &&\n      tree.comments[0].type === 'Block' &&\n      tree.comments[0].data &&\n      tree.comments[0].data._mdxIsPragmaComment\n    ) {\n      tree.comments.shift()\n    }\n\n    // When compiling to a function body, replace the import that was just\n    // generated, and get `jsx`, `jsxs`, and `Fragment` from `arguments[0]`\n    // instead.\n    if (outputFormat === 'function-body') {\n      let index = 0\n\n      // Skip directives: JS currently only has `use strict`, but Acorn allows\n      // arbitrary ones.\n      // Practically things like `use client` could be used?\n      while (index < tree.body.length) {\n        const child = tree.body[index]\n        if ('directive' in child && child.directive) {\n          index++\n        } else {\n          break\n        }\n      }\n\n      const declaration = tree.body[index]\n\n      if (\n        declaration &&\n        declaration.type === 'ImportDeclaration' &&\n        typeof declaration.source.value === 'string' &&\n        /\\/jsx-(dev-)?runtime$/.test(declaration.source.value)\n      ) {\n        tree.body[index] = {\n          type: 'VariableDeclaration',\n          kind: 'const',\n          declarations: specifiersToDeclarations(\n            declaration.specifiers,\n            toIdOrMemberExpression(['arguments', 0])\n          )\n        }\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;;;CASC;;;;;;;;;;AAeM,SAAS,cAAc,OAAO;IACnC,mDAAmD,GACnD,MAAM,EAAC,WAAW,EAAE,YAAY,EAAC,GAAG,WAAW,CAAC;IAEhD;;;;;;;GAOC,GACD,OAAO,SAAU,IAAI,EAAE,IAAI;QACzB,wOAAS,MAAM;YAAC;YAAa,UAAU,KAAK,OAAO,CAAC,EAAE;QAAA;QAEtD,0EAA0E;QAC1E,UAAU;QACV,IACE,KAAK,QAAQ,IACb,KAAK,QAAQ,CAAC,EAAE,CAAC,IAAI,KAAK,WAC1B,KAAK,QAAQ,CAAC,EAAE,CAAC,IAAI,IACrB,KAAK,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,mBAAmB,EACzC;YACA,KAAK,QAAQ,CAAC,KAAK;QACrB;QAEA,sEAAsE;QACtE,uEAAuE;QACvE,WAAW;QACX,IAAI,iBAAiB,iBAAiB;YACpC,IAAI,QAAQ;YAEZ,wEAAwE;YACxE,kBAAkB;YAClB,sDAAsD;YACtD,MAAO,QAAQ,KAAK,IAAI,CAAC,MAAM,CAAE;gBAC/B,MAAM,QAAQ,KAAK,IAAI,CAAC,MAAM;gBAC9B,IAAI,eAAe,SAAS,MAAM,SAAS,EAAE;oBAC3C;gBACF,OAAO;oBACL;gBACF;YACF;YAEA,MAAM,cAAc,KAAK,IAAI,CAAC,MAAM;YAEpC,IACE,eACA,YAAY,IAAI,KAAK,uBACrB,OAAO,YAAY,MAAM,CAAC,KAAK,KAAK,YACpC,wBAAwB,IAAI,CAAC,YAAY,MAAM,CAAC,KAAK,GACrD;gBACA,KAAK,IAAI,CAAC,MAAM,GAAG;oBACjB,MAAM;oBACN,MAAM;oBACN,cAAc,4RACZ,YAAY,UAAU,EACtB,gSAAuB;wBAAC;wBAAa;qBAAE;gBAE3C;YACF;QACF;IACF;AACF"}},
    {"offset": {"line": 1112, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1117, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/estree-util-is-declaration.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Declaration} Declaration\n * @typedef {import('estree-jsx').Node} Node\n */\n\n// Fix to show references to above types in VS Code.\n''\n\n/**\n * Check if `node` is a declaration.\n *\n * @param {Readonly<Node>} node\n *   Node to check.\n * @returns {node is Declaration}\n *   Whether `node` is a declaration.\n */\nexport function isDeclaration(node) {\n  return Boolean(\n    node.type === 'FunctionDeclaration' ||\n      node.type === 'ClassDeclaration' ||\n      node.type === 'VariableDeclaration'\n  )\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED,oDAAoD;;;;AACpD;AAUO,SAAS,cAAc,IAAI;IAChC,OAAO,QACL,KAAK,IAAI,KAAK,yBACZ,KAAK,IAAI,KAAK,sBACd,KAAK,IAAI,KAAK;AAEpB"}},
    {"offset": {"line": 1128, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1133, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/estree-util-declaration-to-expression.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Declaration} Declaration\n * @typedef {import('estree-jsx').Expression} Expression\n */\n\nimport {ok as assert} from 'devlop'\n\n/**\n * Turn a declaration into an expression.\n *\n * Doesn’t work for variable declarations, but that’s fine for our use case\n * because currently we’re using this utility for export default declarations,\n * which can’t contain variable declarations.\n *\n * @param {Readonly<Declaration>} declaration\n *   Declaration.\n * @returns {Expression}\n *   Expression.\n */\nexport function declarationToExpression(declaration) {\n  if (declaration.type === 'FunctionDeclaration') {\n    return {...declaration, type: 'FunctionExpression'}\n  }\n\n  // This is currently an internal utility so the next shouldn’t happen or a\n  // maintainer is making a mistake.\n  assert(declaration.type === 'ClassDeclaration', 'unexpected node type')\n  return {...declaration, type: 'ClassExpression'}\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAgBM,SAAS,wBAAwB,WAAW;IACjD,IAAI,YAAY,IAAI,KAAK,uBAAuB;QAC9C,OAAO;YAAC,GAAG,WAAW;YAAE,MAAM;QAAoB;IACpD;IAEA,0EAA0E;IAC1E,kCAAkC;IAClC,+LAAO,YAAY,IAAI,KAAK,oBAAoB;IAChD,OAAO;QAAC,GAAG,WAAW;QAAE,MAAM;IAAiB;AACjD"}},
    {"offset": {"line": 1157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1162, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/plugin/recma-document.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').CallExpression} CallExpression\n * @typedef {import('estree-jsx').Directive} Directive\n * @typedef {import('estree-jsx').ExportAllDeclaration} ExportAllDeclaration\n * @typedef {import('estree-jsx').ExportDefaultDeclaration} ExportDefaultDeclaration\n * @typedef {import('estree-jsx').ExportNamedDeclaration} ExportNamedDeclaration\n * @typedef {import('estree-jsx').ExportSpecifier} ExportSpecifier\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').FunctionDeclaration} FunctionDeclaration\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportDeclaration} ImportDeclaration\n * @typedef {import('estree-jsx').ImportDefaultSpecifier} ImportDefaultSpecifier\n * @typedef {import('estree-jsx').ImportExpression} ImportExpression\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXElement} JSXElement\n * @typedef {import('estree-jsx').JSXFragment} JSXFragment\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').ModuleDeclaration} ModuleDeclaration\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SimpleLiteral} SimpleLiteral\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n * @typedef {import('estree-jsx').Statement} Statement\n * @typedef {import('estree-jsx').VariableDeclarator} VariableDeclarator\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('../core.js').ProcessorOptions} ProcessorOptions\n */\n\nimport {ok as assert} from 'devlop'\nimport {walk} from 'estree-walker'\nimport {analyze} from 'periscopic'\nimport {positionFromEstree} from 'unist-util-position-from-estree'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nimport {create} from '../util/estree-util-create.js'\nimport {declarationToExpression} from '../util/estree-util-declaration-to-expression.js'\nimport {isDeclaration} from '../util/estree-util-is-declaration.js'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {toIdOrMemberExpression} from '../util/estree-util-to-id-or-member-expression.js'\n\n/**\n * Wrap the estree in `MDXContent`.\n *\n * @param {Readonly<ProcessorOptions>} options\n *   Configuration.\n * @returns\n *   Transform.\n */\nexport function recmaDocument(options) {\n  const baseUrl = options.baseUrl || undefined\n  const baseHref = typeof baseUrl === 'object' ? baseUrl.href : baseUrl\n  const outputFormat = options.outputFormat || 'program'\n  const pragma =\n    options.pragma === undefined ? 'React.createElement' : options.pragma\n  const pragmaFrag =\n    options.pragmaFrag === undefined ? 'React.Fragment' : options.pragmaFrag\n  const pragmaImportSource = options.pragmaImportSource || 'react'\n  const jsxImportSource = options.jsxImportSource || 'react'\n  const jsxRuntime = options.jsxRuntime || 'automatic'\n\n  /**\n   * @param {Program} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    /** @type {Array<[string, string] | string>} */\n    const exportedIdentifiers = []\n    /** @type {Array<Directive | ModuleDeclaration | Statement>} */\n    const replacement = []\n    /** @type {Array<string>} */\n    const pragmas = []\n    let exportAllCount = 0\n    /** @type {ExportDefaultDeclaration | ExportSpecifier | undefined} */\n    let layout\n    /** @type {boolean | undefined} */\n    let content\n    /** @type {Node} */\n    let child\n\n    if (jsxRuntime) {\n      pragmas.push('@jsxRuntime ' + jsxRuntime)\n    }\n\n    if (jsxRuntime === 'automatic' && jsxImportSource) {\n      pragmas.push('@jsxImportSource ' + jsxImportSource)\n    }\n\n    if (jsxRuntime === 'classic' && pragma) {\n      pragmas.push('@jsx ' + pragma)\n    }\n\n    if (jsxRuntime === 'classic' && pragmaFrag) {\n      pragmas.push('@jsxFrag ' + pragmaFrag)\n    }\n\n    /* c8 ignore next -- comments can be missing in the types, we always have it. */\n    if (!tree.comments) tree.comments = []\n\n    if (pragmas.length > 0) {\n      tree.comments.unshift({\n        type: 'Block',\n        value: pragmas.join(' '),\n        data: {_mdxIsPragmaComment: true}\n      })\n    }\n\n    if (jsxRuntime === 'classic' && pragmaImportSource) {\n      if (!pragma) {\n        throw new Error(\n          'Missing `pragma` in classic runtime with `pragmaImportSource`'\n        )\n      }\n\n      handleEsm({\n        type: 'ImportDeclaration',\n        specifiers: [\n          {\n            type: 'ImportDefaultSpecifier',\n            local: {type: 'Identifier', name: pragma.split('.')[0]}\n          }\n        ],\n        source: {type: 'Literal', value: pragmaImportSource}\n      })\n    }\n\n    // Find the `export default`, the JSX expression, and leave the rest\n    // (import/exports) as they are.\n    for (child of tree.body) {\n      // ```tsx\n      // export default props => <>{props.children}</>\n      // ```\n      //\n      // Treat it as an inline layout declaration.\n      if (child.type === 'ExportDefaultDeclaration') {\n        if (layout) {\n          file.fail(\n            'Unexpected duplicate layout, expected a single layout (previous: ' +\n              stringifyPosition(positionFromEstree(layout)) +\n              ')',\n            {\n              ancestors: [tree, child],\n              place: positionFromEstree(child),\n              ruleId: 'duplicate-layout',\n              source: 'recma-document'\n            }\n          )\n        }\n\n        layout = child\n        replacement.push({\n          type: 'VariableDeclaration',\n          kind: 'const',\n          declarations: [\n            {\n              type: 'VariableDeclarator',\n              id: {type: 'Identifier', name: 'MDXLayout'},\n              init: isDeclaration(child.declaration)\n                ? declarationToExpression(child.declaration)\n                : child.declaration\n            }\n          ]\n        })\n      }\n      // ```tsx\n      // export {a, b as c} from 'd'\n      // ```\n      else if (child.type === 'ExportNamedDeclaration' && child.source) {\n        // Cast because always simple.\n        const source = /** @type {SimpleLiteral} */ (child.source)\n\n        // Remove `default` or `as default`, but not `default as`, specifier.\n        child.specifiers = child.specifiers.filter(function (specifier) {\n          if (specifier.exported.name === 'default') {\n            if (layout) {\n              file.fail(\n                'Unexpected duplicate layout, expected a single layout (previous: ' +\n                  stringifyPosition(positionFromEstree(layout)) +\n                  ')',\n                {\n                  ancestors: [tree, child, specifier],\n                  place: positionFromEstree(child),\n                  ruleId: 'duplicate-layout',\n                  source: 'recma-document'\n                }\n              )\n            }\n\n            layout = specifier\n\n            // Make it just an import: `import MDXLayout from '…'`.\n            /** @type {Array<ImportDefaultSpecifier | ImportSpecifier>} */\n            const specifiers = []\n\n            // Default as default / something else as default.\n            if (specifier.local.name === 'default') {\n              specifiers.push({\n                type: 'ImportDefaultSpecifier',\n                local: {type: 'Identifier', name: 'MDXLayout'}\n              })\n            } else {\n              /** @type {ImportSpecifier} */\n              const importSpecifier = {\n                type: 'ImportSpecifier',\n                imported: specifier.local,\n                local: {type: 'Identifier', name: 'MDXLayout'}\n              }\n              create(specifier.local, importSpecifier)\n              specifiers.push(importSpecifier)\n            }\n\n            /** @type {Literal} */\n            const from = {type: 'Literal', value: source.value}\n            create(source, from)\n\n            /** @type {ImportDeclaration} */\n            const declaration = {\n              type: 'ImportDeclaration',\n              specifiers,\n              source: from\n            }\n            create(specifier, declaration)\n            handleEsm(declaration)\n\n            return false\n          }\n\n          return true\n        })\n\n        // If there are other things imported, keep it.\n        if (child.specifiers.length > 0) {\n          handleExport(child)\n        }\n      }\n      // ```tsx\n      // export {a, b as c}\n      // export * from 'a'\n      // ```\n      else if (\n        child.type === 'ExportNamedDeclaration' ||\n        child.type === 'ExportAllDeclaration'\n      ) {\n        handleExport(child)\n      } else if (child.type === 'ImportDeclaration') {\n        handleEsm(child)\n      } else if (\n        child.type === 'ExpressionStatement' &&\n        (child.expression.type === 'JSXElement' ||\n          // @ts-expect-error: `estree-jsx` does not register `JSXFragment` as an expression.\n          child.expression.type === 'JSXFragment')\n      ) {\n        content = true\n        replacement.push(\n          ...createMdxContent(child.expression, outputFormat, Boolean(layout))\n        )\n      } else {\n        // This catch-all branch is because plugins might add other things.\n        // Normally, we only have import/export/jsx, but just add whatever’s\n        // there.\n        replacement.push(child)\n      }\n    }\n\n    // If there was no JSX content at all, add an empty function.\n    if (!content) {\n      replacement.push(\n        ...createMdxContent(undefined, outputFormat, Boolean(layout))\n      )\n    }\n\n    exportedIdentifiers.push(['MDXContent', 'default'])\n\n    if (outputFormat === 'function-body') {\n      replacement.push({\n        type: 'ReturnStatement',\n        argument: {\n          type: 'ObjectExpression',\n          properties: [\n            ...Array.from({length: exportAllCount}).map(\n              /**\n               * @param {undefined} _\n               *   Nothing.\n               * @param {number} index\n               *   Index.\n               * @returns {SpreadElement}\n               *   Node.\n               */\n              function (_, index) {\n                return {\n                  type: 'SpreadElement',\n                  argument: {\n                    type: 'Identifier',\n                    name: '_exportAll' + (index + 1)\n                  }\n                }\n              }\n            ),\n            ...exportedIdentifiers.map(function (d) {\n              /** @type {Property} */\n              const prop = {\n                type: 'Property',\n                kind: 'init',\n                method: false,\n                computed: false,\n                shorthand: typeof d === 'string',\n                key: {\n                  type: 'Identifier',\n                  name: typeof d === 'string' ? d : d[1]\n                },\n                value: {\n                  type: 'Identifier',\n                  name: typeof d === 'string' ? d : d[0]\n                }\n              }\n\n              return prop\n            })\n          ]\n        }\n      })\n    }\n\n    tree.body = replacement\n\n    let usesImportMetaUrlVariable = false\n    let usesResolveDynamicHelper = false\n\n    if (baseHref || outputFormat === 'function-body') {\n      walk(tree, {\n        enter(node) {\n          if (\n            (node.type === 'ExportAllDeclaration' ||\n              node.type === 'ExportNamedDeclaration' ||\n              node.type === 'ImportDeclaration') &&\n            node.source\n          ) {\n            // We never hit this branch when generating function bodies, as\n            // statements are already compiled away into import expressions.\n            assert(baseHref, 'unexpected missing `baseHref` in branch')\n\n            let value = node.source.value\n            // The literal source for statements can only be string.\n            assert(typeof value === 'string', 'expected string source')\n\n            // Resolve a specifier.\n            // This is the same as `_resolveDynamicMdxSpecifier`, which has to\n            // be injected to work with expressions at runtime, but as we have\n            // `baseHref` at compile time here and statements are static\n            // strings, we can do it now.\n            try {\n              // To do: use `URL.canParse` next major.\n              // eslint-disable-next-line no-new\n              new URL(value)\n              // Fine: a full URL.\n            } catch {\n              if (\n                value.startsWith('/') ||\n                value.startsWith('./') ||\n                value.startsWith('../')\n              ) {\n                value = new URL(value, baseHref).href\n              } else {\n                // Fine: are bare specifier.\n              }\n            }\n\n            /** @type {SimpleLiteral} */\n            const replacement = {type: 'Literal', value}\n            create(node.source, replacement)\n            node.source = replacement\n            return\n          }\n\n          if (node.type === 'ImportExpression') {\n            usesResolveDynamicHelper = true\n            /** @type {CallExpression} */\n            const replacement = {\n              type: 'CallExpression',\n              callee: {type: 'Identifier', name: '_resolveDynamicMdxSpecifier'},\n              arguments: [node.source],\n              optional: false\n            }\n            node.source = replacement\n            return\n          }\n\n          // To do: add support for `import.meta.resolve`.\n\n          if (\n            node.type === 'MemberExpression' &&\n            'object' in node &&\n            node.object.type === 'MetaProperty' &&\n            node.property.type === 'Identifier' &&\n            node.object.meta.name === 'import' &&\n            node.object.property.name === 'meta' &&\n            node.property.name === 'url'\n          ) {\n            usesImportMetaUrlVariable = true\n            /** @type {Identifier} */\n            const replacement = {type: 'Identifier', name: '_importMetaUrl'}\n            create(node, replacement)\n            this.replace(replacement)\n          }\n        }\n      })\n    }\n\n    if (usesResolveDynamicHelper) {\n      if (!baseHref) {\n        usesImportMetaUrlVariable = true\n      }\n\n      tree.body.push(\n        resolveDynamicMdxSpecifier(\n          baseHref\n            ? {type: 'Literal', value: baseHref}\n            : {type: 'Identifier', name: '_importMetaUrl'}\n        )\n      )\n    }\n\n    if (usesImportMetaUrlVariable) {\n      assert(\n        outputFormat === 'function-body',\n        'expected `function-body` when using dynamic url injection'\n      )\n      tree.body.unshift(...createImportMetaUrlVariable())\n    }\n\n    /**\n     * @param {ExportAllDeclaration | ExportNamedDeclaration} node\n     *   Export node.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    function handleExport(node) {\n      if (node.type === 'ExportNamedDeclaration') {\n        // ```tsx\n        // export function a() {}\n        // export class A {}\n        // export var a = 1\n        // ```\n        if (node.declaration) {\n          exportedIdentifiers.push(\n            ...analyze(node.declaration).scope.declarations.keys()\n          )\n        }\n\n        // ```tsx\n        // export {a, b as c}\n        // export {a, b as c} from 'd'\n        // ```\n        for (child of node.specifiers) {\n          exportedIdentifiers.push(child.exported.name)\n        }\n      }\n\n      handleEsm(node)\n    }\n\n    /**\n     * @param {ExportAllDeclaration | ExportNamedDeclaration | ImportDeclaration} node\n     *   Export or import node.\n     * @returns {undefined}\n     *   Nothing.\n     */\n    function handleEsm(node) {\n      /** @type {ModuleDeclaration | Statement | undefined} */\n      let replace\n      /** @type {Expression} */\n      let init\n\n      if (outputFormat === 'function-body') {\n        if (\n          // Always have a source:\n          node.type === 'ImportDeclaration' ||\n          node.type === 'ExportAllDeclaration' ||\n          // Source optional:\n          (node.type === 'ExportNamedDeclaration' && node.source)\n        ) {\n          // We always have a source, but types say they can be missing.\n          assert(node.source, 'expected `node.source` to be defined')\n\n          // ```\n          // import 'a'\n          // //=> await import('a')\n          // import a from 'b'\n          // //=> const {default: a} = await import('b')\n          // export {a, b as c} from 'd'\n          // //=> const {a, c: b} = await import('d')\n          // export * from 'a'\n          // //=> const _exportAll0 = await import('a')\n          // ```\n          /** @type {ImportExpression} */\n          const argument = {type: 'ImportExpression', source: node.source}\n          create(node, argument)\n          init = {type: 'AwaitExpression', argument}\n\n          if (\n            (node.type === 'ImportDeclaration' ||\n              node.type === 'ExportNamedDeclaration') &&\n            node.specifiers.length === 0\n          ) {\n            replace = {type: 'ExpressionStatement', expression: init}\n          } else {\n            replace = {\n              type: 'VariableDeclaration',\n              kind: 'const',\n              declarations:\n                node.type === 'ExportAllDeclaration'\n                  ? [\n                      {\n                        type: 'VariableDeclarator',\n                        id: {\n                          type: 'Identifier',\n                          name: '_exportAll' + ++exportAllCount\n                        },\n                        init\n                      }\n                    ]\n                  : specifiersToDeclarations(node.specifiers, init)\n            }\n          }\n        } else if (node.declaration) {\n          replace = node.declaration\n        } else {\n          /** @type {Array<VariableDeclarator>} */\n          const declarators = node.specifiers\n            .filter(function (specifier) {\n              return specifier.local.name !== specifier.exported.name\n            })\n            .map(function (specifier) {\n              return {\n                type: 'VariableDeclarator',\n                id: specifier.exported,\n                init: specifier.local\n              }\n            })\n\n          if (declarators.length > 0) {\n            replace = {\n              type: 'VariableDeclaration',\n              kind: 'const',\n              declarations: declarators\n            }\n          }\n        }\n      } else {\n        replace = node\n      }\n\n      if (replace) {\n        replacement.push(replace)\n      }\n    }\n  }\n\n  /**\n   * @param {Readonly<Expression> | undefined} content\n   *   Content.\n   * @param {'function-body' | 'program'} outputFormat\n   *   Output format.\n   * @param {boolean | undefined} [hasInternalLayout=false]\n   *   Whether there’s an internal layout (default: `false`).\n   * @returns {Array<ExportDefaultDeclaration | FunctionDeclaration>}\n   *   Functions.\n   */\n  function createMdxContent(content, outputFormat, hasInternalLayout) {\n    /** @type {JSXElement} */\n    const element = {\n      type: 'JSXElement',\n      openingElement: {\n        type: 'JSXOpeningElement',\n        name: {type: 'JSXIdentifier', name: 'MDXLayout'},\n        attributes: [\n          {\n            type: 'JSXSpreadAttribute',\n            argument: {type: 'Identifier', name: 'props'}\n          }\n        ],\n        selfClosing: false\n      },\n      closingElement: {\n        type: 'JSXClosingElement',\n        name: {type: 'JSXIdentifier', name: 'MDXLayout'}\n      },\n      children: [\n        {\n          type: 'JSXElement',\n          openingElement: {\n            type: 'JSXOpeningElement',\n            name: {type: 'JSXIdentifier', name: '_createMdxContent'},\n            attributes: [\n              {\n                type: 'JSXSpreadAttribute',\n                argument: {type: 'Identifier', name: 'props'}\n              }\n            ],\n            selfClosing: true\n          },\n          closingElement: null,\n          children: []\n        }\n      ]\n    }\n\n    let result = /** @type {Expression} */ (element)\n\n    if (!hasInternalLayout) {\n      result = {\n        type: 'ConditionalExpression',\n        test: {type: 'Identifier', name: 'MDXLayout'},\n        consequent: result,\n        alternate: {\n          type: 'CallExpression',\n          callee: {type: 'Identifier', name: '_createMdxContent'},\n          arguments: [{type: 'Identifier', name: 'props'}],\n          optional: false\n        }\n      }\n    }\n\n    let argument =\n      // Cast because TS otherwise does not think `JSXFragment`s are expressions.\n      /** @type {Readonly<Expression> | Readonly<JSXFragment>} */ (\n        content || {type: 'Identifier', name: 'undefined'}\n      )\n\n    // Unwrap a fragment of a single element.\n    if (\n      argument.type === 'JSXFragment' &&\n      argument.children.length === 1 &&\n      argument.children[0].type === 'JSXElement'\n    ) {\n      argument = argument.children[0]\n    }\n\n    let awaitExpression = false\n\n    walk(argument, {\n      enter(node) {\n        if (\n          node.type === 'ArrowFunctionExpression' ||\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression'\n        ) {\n          return this.skip()\n        }\n\n        if (\n          node.type === 'AwaitExpression' ||\n          /* c8 ignore next 2 -- can only occur in a function (which then can\n           * only be async, so skipped it) */\n          (node.type === 'ForOfStatement' && node.await)\n        ) {\n          awaitExpression = true\n        }\n      }\n    })\n\n    /** @type {FunctionDeclaration} */\n    const declaration = {\n      type: 'FunctionDeclaration',\n      id: {type: 'Identifier', name: 'MDXContent'},\n      params: [\n        {\n          type: 'AssignmentPattern',\n          left: {type: 'Identifier', name: 'props'},\n          right: {type: 'ObjectExpression', properties: []}\n        }\n      ],\n      body: {\n        type: 'BlockStatement',\n        body: [{type: 'ReturnStatement', argument: result}]\n      }\n    }\n\n    return [\n      {\n        type: 'FunctionDeclaration',\n        async: awaitExpression,\n        id: {type: 'Identifier', name: '_createMdxContent'},\n        params: [{type: 'Identifier', name: 'props'}],\n        body: {\n          type: 'BlockStatement',\n          body: [\n            {\n              type: 'ReturnStatement',\n              // Cast because TS doesn’t think `JSXFragment` is an expression.\n              // eslint-disable-next-line object-shorthand\n              argument: /** @type {Expression} */ (argument)\n            }\n          ]\n        }\n      },\n      outputFormat === 'program'\n        ? {type: 'ExportDefaultDeclaration', declaration}\n        : declaration\n    ]\n  }\n}\n\n/**\n * @param {Expression} importMetaUrl\n * @returns {FunctionDeclaration}\n */\nfunction resolveDynamicMdxSpecifier(importMetaUrl) {\n  return {\n    type: 'FunctionDeclaration',\n    id: {type: 'Identifier', name: '_resolveDynamicMdxSpecifier'},\n    generator: false,\n    async: false,\n    params: [{type: 'Identifier', name: 'd'}],\n    body: {\n      type: 'BlockStatement',\n      body: [\n        {\n          type: 'IfStatement',\n          test: {\n            type: 'BinaryExpression',\n            left: {\n              type: 'UnaryExpression',\n              operator: 'typeof',\n              prefix: true,\n              argument: {type: 'Identifier', name: 'd'}\n            },\n            operator: '!==',\n            right: {type: 'Literal', value: 'string'}\n          },\n          consequent: {\n            type: 'ReturnStatement',\n            argument: {type: 'Identifier', name: 'd'}\n          },\n          alternate: null\n        },\n        // To do: use `URL.canParse` when widely supported (see commented\n        // out code below).\n        {\n          type: 'TryStatement',\n          block: {\n            type: 'BlockStatement',\n            body: [\n              {\n                type: 'ExpressionStatement',\n                expression: {\n                  type: 'NewExpression',\n                  callee: {type: 'Identifier', name: 'URL'},\n                  arguments: [{type: 'Identifier', name: 'd'}]\n                }\n              },\n              {\n                type: 'ReturnStatement',\n                argument: {type: 'Identifier', name: 'd'}\n              }\n            ]\n          },\n          handler: {\n            type: 'CatchClause',\n            param: null,\n            body: {type: 'BlockStatement', body: []}\n          },\n          finalizer: null\n        },\n        // To do: use `URL.canParse` when widely supported.\n        // {\n        //   type: 'IfStatement',\n        //   test: {\n        //     type: 'CallExpression',\n        //     callee: toIdOrMemberExpression(['URL', 'canParse']),\n        //     arguments: [{type: 'Identifier', name: 'd'}],\n        //     optional: false\n        //   },\n        //   consequent: {\n        //     type: 'ReturnStatement',\n        //     argument: {type: 'Identifier', name: 'd'}\n        //   },\n        //   alternate: null\n        // },\n        {\n          type: 'IfStatement',\n          test: {\n            type: 'LogicalExpression',\n            left: {\n              type: 'LogicalExpression',\n              left: {\n                type: 'CallExpression',\n                callee: toIdOrMemberExpression(['d', 'startsWith']),\n                arguments: [{type: 'Literal', value: '/'}],\n                optional: false\n              },\n              operator: '||',\n              right: {\n                type: 'CallExpression',\n                callee: toIdOrMemberExpression(['d', 'startsWith']),\n                arguments: [{type: 'Literal', value: './'}],\n                optional: false\n              }\n            },\n            operator: '||',\n            right: {\n              type: 'CallExpression',\n              callee: toIdOrMemberExpression(['d', 'startsWith']),\n              arguments: [{type: 'Literal', value: '../'}],\n              optional: false\n            }\n          },\n          consequent: {\n            type: 'ReturnStatement',\n            argument: {\n              type: 'MemberExpression',\n              object: {\n                type: 'NewExpression',\n                callee: {type: 'Identifier', name: 'URL'},\n                arguments: [{type: 'Identifier', name: 'd'}, importMetaUrl]\n              },\n              property: {type: 'Identifier', name: 'href'},\n              computed: false,\n              optional: false\n            }\n          },\n          alternate: null\n        },\n        {\n          type: 'ReturnStatement',\n          argument: {type: 'Identifier', name: 'd'}\n        }\n      ]\n    }\n  }\n}\n\n/**\n * @returns {Array<Statement>}\n */\nfunction createImportMetaUrlVariable() {\n  return [\n    {\n      type: 'VariableDeclaration',\n      declarations: [\n        {\n          type: 'VariableDeclarator',\n          id: {type: 'Identifier', name: '_importMetaUrl'},\n          init: toIdOrMemberExpression(['arguments', 0, 'baseUrl'])\n        }\n      ],\n      kind: 'const'\n    },\n    {\n      type: 'IfStatement',\n      test: {\n        type: 'UnaryExpression',\n        operator: '!',\n        prefix: true,\n        argument: {type: 'Identifier', name: '_importMetaUrl'}\n      },\n      consequent: {\n        type: 'ThrowStatement',\n        argument: {\n          type: 'NewExpression',\n          callee: {type: 'Identifier', name: 'Error'},\n          arguments: [\n            {\n              type: 'Literal',\n              value:\n                'Unexpected missing `options.baseUrl` needed to support `export … from`, `import`, or `import.meta.url` when generating `function-body`'\n            }\n          ]\n        }\n      },\n      alternate: null\n    }\n  ]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2054, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2059, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/core.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('hast-util-to-estree').ElementAttributeNameCase} ElementAttributeNameCase\n * @typedef {import('hast-util-to-estree').StylePropertyNameCase} StylePropertyNameCase\n * @typedef {import('mdast').Root} Root\n * @typedef {import('remark-rehype').Options} RemarkRehypeOptions\n * @typedef {typeof import('source-map').SourceMapGenerator} SourceMapGenerator\n * @typedef {import('unified').PluggableList} PluggableList\n * @typedef {import('unified').Processor<Root, Program, Program, Program, string>} Processor\n */\n\n/**\n * @typedef ProcessorOptions\n *   Configuration for `createProcessor`.\n * @property {SourceMapGenerator | null | undefined} [SourceMapGenerator]\n *   Add a source map (object form) as the `map` field on the resulting file\n *   (optional).\n * @property {URL | string | null | undefined} [baseUrl]\n *   Use this URL as `import.meta.url` and resolve `import` and `export … from`\n *   relative to it (optional, example: `import.meta.url`).\n * @property {boolean | null | undefined} [development=false]\n *   Whether to add extra info to error messages in generated code and use the\n *   development automatic JSX runtime (`Fragment` and `jsxDEV` from\n *   `/jsx-dev-runtime`) (default: `false`);\n *   when using the webpack loader (`@mdx-js/loader`) or the Rollup integration\n *   (`@mdx-js/rollup`) through Vite, this is automatically inferred from how\n *   you configure those tools.\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Casing to use for attribute names (default: `'react'`);\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`;\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`;\n *   for JSX components written in MDX, the author has to be aware of which\n *   framework they use and write code accordingly;\n *   for AST nodes generated by this project, this option configures it\n * @property {'md' | 'mdx' | null | undefined} [format='mdx']\n *   format of the file (default: `'mdx'`);\n *   `'md'` means treat as markdown and `'mdx'` means treat as MDX.\n * @property {boolean | null | undefined} [jsx=false]\n *   Whether to keep JSX (default: `false`);\n *   the default is to compile JSX away so that the resulting file is\n *   immediately runnable.\n * @property {string | null | undefined} [jsxImportSource='react']\n *   Place to import automatic JSX runtimes from (default: `'react'`);\n *   when in the `automatic` runtime, this is used to define an import for\n *   `Fragment`, `jsx`, `jsxDEV`, and `jsxs`.\n * @property {'automatic' | 'classic' | null | undefined} [jsxRuntime='automatic']\n *   JSX runtime to use (default: `'automatic'`);\n *   the automatic runtime compiles to `import _jsx from\n *   '$importSource/jsx-runtime'\\n_jsx('p')`;\n *   the classic runtime compiles to calls such as `h('p')`.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {ReadonlyArray<string> | null | undefined} [mdExtensions]\n *   List of markdown extensions, with dot (default: `['.md', '.markdown', …]`);\n *   affects integrations.\n * @property {ReadonlyArray<string> | null | undefined} [mdxExtensions]\n *   List of MDX extensions, with dot (default: `['.mdx']`);\n *   affects integrations.\n * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']\n *   Output format to generate (default: `'program'`);\n *   in most cases `'program'` should be used, it results in a whole program;\n *   internally `evaluate` uses `'function-body'` to compile to\n *   code that can be passed to `run`;\n *   in some cases, you might want what `evaluate` does in separate steps, such\n *   as when compiling on the server and running on the client.\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Pragma for JSX, used in the classic runtime as an identifier for function\n *   calls: `<x />` to `React.createElement('x')` (default:\n *   `'React.createElement'`);\n *   when changing this, you should also define `pragmaFrag` and\n *   `pragmaImportSource` too.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Pragma for fragment symbol, used in the classic runtime as an identifier\n *   for unnamed calls: `<>` to `React.createElement(React.Fragment)` (default:\n *   `'React.Fragment'`);\n *   when changing this, you should also define `pragma` and\n *   `pragmaImportSource` too.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {string | null | undefined} [pragmaImportSource='react']\n *   Where to import the identifier of `pragma` from, used in the classic\n *   runtime (default: `'react'`);\n *   to illustrate, when `pragma` is `'a.b'` and `pragmaImportSource` is `'c'`\n *   the following will be generated: `import a from 'c'` and things such as\n *   `a.b('h1', {})`.\n *   when changing this, you should also define `pragma` and `pragmaFrag` too.\n *\n *   > 👉 **Note**: support for the classic runtime is deprecated and will\n *   > likely be removed in the next major version.\n * @property {string | null | undefined} [providerImportSource]\n *   Place to import a provider from (optional, example: `'@mdx-js/react'`);\n *   normally it’s used for runtimes that support context (React, Preact), but\n *   it can be used to inject components into the compiled code;\n *   the module must export and identifier `useMDXComponents` which is called\n *   without arguments to get an object of components (`MDXComponents` from\n *   `mdx/types.js`).\n * @property {PluggableList | null | undefined} [recmaPlugins]\n *   List of recma plugins (optional);\n *   this is a new ecosystem, currently in beta, to transform esast trees\n *   (JavaScript)\n * @property {PluggableList | null | undefined} [remarkPlugins]\n *   List of remark plugins (optional).\n * @property {PluggableList | null | undefined} [rehypePlugins]\n *   List of rehype plugins (optional).\n * @property {Readonly<RemarkRehypeOptions> | null | undefined} [remarkRehypeOptions]\n *   Options to pass through to `remark-rehype` (optional);\n *   the option `allowDangerousHtml` will always be set to `true` and the MDX\n *   nodes (see `nodeTypes`) are passed through;\n *   In particular, you might want to pass configuration for footnotes if your\n *   content is not in English.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Casing to use for property names in `style` objects (default: `'dom'`);\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`;\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`;\n *   for JSX components written in MDX, the author has to be aware of which\n *   framework they use and write code accordingly;\n *   for AST nodes generated by this project, this option configures it\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n */\n\nimport {unreachable} from 'devlop'\nimport remarkMdx from 'remark-mdx'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport {unified} from 'unified'\nimport {recmaDocument} from './plugin/recma-document.js'\nimport {recmaJsxBuild} from './plugin/recma-jsx-build.js'\nimport {recmaJsxRewrite} from './plugin/recma-jsx-rewrite.js'\nimport {recmaStringify} from './plugin/recma-stringify.js'\nimport {rehypeRecma} from './plugin/rehype-recma.js'\nimport {rehypeRemoveRaw} from './plugin/rehype-remove-raw.js'\nimport {remarkMarkAndUnravel} from './plugin/remark-mark-and-unravel.js'\nimport {nodeTypes} from './node-types.js'\n\nconst removedOptions = [\n  'compilers',\n  'filepath',\n  'hastPlugins',\n  'mdPlugins',\n  'skipExport',\n  'wrapExport'\n]\n\nlet warned = false\n\n/**\n * Create a processor to compile markdown or MDX to JavaScript.\n *\n * > **Note**: `format: 'detect'` is not allowed in `ProcessorOptions`.\n *\n * @param {Readonly<ProcessorOptions> | null | undefined} [options]\n *   Configuration (optional).\n * @return {Processor}\n *   Processor.\n */\nexport function createProcessor(options) {\n  const settings = options || {}\n  let index = -1\n\n  while (++index < removedOptions.length) {\n    const key = removedOptions[index]\n    if (key in settings) {\n      unreachable(\n        'Unexpected removed option `' +\n          key +\n          '`; see <https://mdxjs.com/migrating/v2/> on how to migrate'\n      )\n    }\n  }\n\n  // @ts-expect-error: throw an error for a runtime value which is not allowed\n  // by the types.\n  if (settings.format === 'detect') {\n    unreachable(\n      \"Unexpected `format: 'detect'`, which is not supported by `createProcessor`, expected `'mdx'` or `'md'`\"\n    )\n  }\n\n  if (\n    (settings.jsxRuntime === 'classic' ||\n      settings.pragma ||\n      settings.pragmaFrag ||\n      settings.pragmaImportSource) &&\n    !warned\n  ) {\n    warned = true\n    console.warn(\n      \"Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate\"\n    )\n  }\n\n  const pipeline = unified().use(remarkParse)\n\n  if (settings.format !== 'md') {\n    pipeline.use(remarkMdx)\n  }\n\n  const remarkRehypeOptions = settings.remarkRehypeOptions || {}\n\n  pipeline\n    .use(remarkMarkAndUnravel)\n    .use(settings.remarkPlugins || [])\n    .use(remarkRehype, {\n      ...remarkRehypeOptions,\n      allowDangerousHtml: true,\n      passThrough: [...(remarkRehypeOptions.passThrough || []), ...nodeTypes]\n    })\n    .use(settings.rehypePlugins || [])\n\n  if (settings.format === 'md') {\n    pipeline.use(rehypeRemoveRaw)\n  }\n\n  pipeline\n    .use(rehypeRecma, settings)\n    .use(recmaDocument, settings)\n    .use(recmaJsxRewrite, settings)\n\n  if (!settings.jsx) {\n    pipeline.use(recmaJsxBuild, settings)\n  }\n\n  pipeline.use(recmaStringify, settings).use(settings.recmaPlugins || [])\n\n  // @ts-expect-error: we added plugins with if-checks, which TS doesn’t get.\n  return pipeline\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkHC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBD,MAAM,iBAAiB;IACrB;IACA;IACA;IACA;IACA;IACA;CACD;AAED,IAAI,SAAS;AAYN,SAAS,gBAAgB,OAAO;IACrC,MAAM,WAAW,WAAW,CAAC;IAC7B,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,eAAe,MAAM,CAAE;QACtC,MAAM,MAAM,cAAc,CAAC,MAAM;QACjC,IAAI,OAAO,UAAU;YACnB,wMACE,gCACE,MACA;QAEN;IACF;IAEA,4EAA4E;IAC5E,gBAAgB;IAChB,IAAI,SAAS,MAAM,KAAK,UAAU;QAChC,wMACE;IAEJ;IAEA,IACE,CAAC,SAAS,UAAU,KAAK,aACvB,SAAS,MAAM,IACf,SAAS,UAAU,IACnB,SAAS,kBAAkB,KAC7B,CAAC,QACD;QACA,SAAS;QACT,QAAQ,IAAI,CACV;IAEJ;IAEA,MAAM,WAAW,4LAAU,GAAG;IAE9B,IAAI,SAAS,MAAM,KAAK,MAAM;QAC5B,SAAS,GAAG;IACd;IAEA,MAAM,sBAAsB,SAAS,mBAAmB,IAAI,CAAC;IAE7D,SACG,GAAG,0QACH,GAAG,CAAC,SAAS,aAAa,IAAI,EAAE,EAChC,GAAG,8MAAe;QACjB,GAAG,mBAAmB;QACtB,oBAAoB;QACpB,aAAa;eAAK,oBAAoB,WAAW,IAAI,EAAE;;SAAgB;IACzE,GACC,GAAG,CAAC,SAAS,aAAa,IAAI,EAAE;IAEnC,IAAI,SAAS,MAAM,KAAK,MAAM;QAC5B,SAAS,GAAG;IACd;IAEA,SACG,GAAG,gPAAc,UACjB,GAAG,oPAAgB,UACnB,GAAG,4PAAkB;IAExB,IAAI,CAAC,SAAS,GAAG,EAAE;QACjB,SAAS,GAAG,wPAAgB;IAC9B;IAEA,SAAS,GAAG,sPAAiB,UAAU,GAAG,CAAC,SAAS,YAAY,IAAI,EAAE;IAEtE,2EAA2E;IAC3E,OAAO;AACT"}},
    {"offset": {"line": 2263, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2268, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/extnames.js"],"sourcesContent":["import markdownExtensions from 'markdown-extensions'\n\nexport const md = markdownExtensions.map(function (d) {\n  return '.' + d\n})\nexport const mdx = ['.mdx']\n"],"names":[],"mappings":";;;;;;;AAEO,MAAM,KAAK,uNAAmB,GAAG,CAAC,SAAU,CAAC;IAClD,OAAO,MAAM;AACf;AACO,MAAM,MAAM;IAAC;CAAO"}},
    {"offset": {"line": 2281, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2286, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/resolve-file-and-options.js"],"sourcesContent":["/**\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('../compile.js').CompileOptions} CompileOptions\n * @typedef {import('../core.js').ProcessorOptions} ProcessorOptions\n */\n\nimport {VFile} from 'vfile'\nimport {md} from './extnames.js'\n\n/**\n * Create a file and options from a given `vfileCompatible` and options that\n * might contain `format: 'detect'`.\n *\n * @param {Readonly<Compatible>} vfileCompatible\n *   File.\n * @param {Readonly<CompileOptions> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {{file: VFile, options: ProcessorOptions}}\n *   File and options.\n */\nexport function resolveFileAndOptions(vfileCompatible, options) {\n  const file = looksLikeAVFile(vfileCompatible)\n    ? vfileCompatible\n    : new VFile(vfileCompatible)\n  const {format, ...rest} = options || {}\n  return {\n    file,\n    options: {\n      format:\n        format === 'md' || format === 'mdx'\n          ? format\n          : file.extname && (rest.mdExtensions || md).includes(file.extname)\n          ? 'md'\n          : 'mdx',\n      ...rest\n    }\n  }\n}\n\n/**\n * @param {Readonly<Compatible> | null | undefined} [value]\n *   Thing.\n * @returns {value is VFile}\n *   Check.\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;AAgBM,SAAS,sBAAsB,eAAe,EAAE,OAAO;IAC5D,MAAM,OAAO,gBAAgB,mBACzB,kBACA,uLAAU;IACd,MAAM,EAAC,MAAM,EAAE,GAAG,MAAK,GAAG,WAAW,CAAC;IACtC,OAAO;QACL;QACA,SAAS;YACP,QACE,WAAW,QAAQ,WAAW,QAC1B,SACA,KAAK,OAAO,IAAI,CAAC,KAAK,YAAY,+NAAM,EAAE,QAAQ,CAAC,KAAK,OAAO,IAC/D,OACA;YACN,GAAG,IAAI;QACT;IACF;AACF;AAEA;;;;;CAKC,GACD,SAAS,gBAAgB,KAAK;IAC5B,OAAO,QACL,SACE,OAAO,UAAU,YACjB,aAAa,SACb,cAAc;AAEpB"}},
    {"offset": {"line": 2317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2322, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/compile.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('./core.js').ProcessorOptions} ProcessorOptions\n */\n\n/**\n * @typedef {Omit<ProcessorOptions, 'format'>} CoreProcessorOptions\n *   Core configuration.\n *\n * @typedef ExtraOptions\n *   Extra configuration.\n * @property {'detect' | 'md' | 'mdx' | null | undefined} [format='detect']\n *   Format of `file` (default: `'detect'`).\n *\n * @typedef {CoreProcessorOptions & ExtraOptions} CompileOptions\n *   Configuration for `compile`.\n *\n *   `CompileOptions` is the same as `ProcessorOptions` with the exception that\n *   the `format` option supports a `'detect'` value, which is the default.\n *   The `'detect'` format means to use `'md'` for files with an extension in\n *   `mdExtensions` and `'mdx'` otherwise.\n */\n\nimport {resolveFileAndOptions} from './util/resolve-file-and-options.js'\nimport {createProcessor} from './core.js'\n\n/**\n * Compile MDX to JS.\n *\n * @param {Readonly<Compatible>} vfileCompatible\n *   MDX document to parse.\n * @param {Readonly<CompileOptions> | null | undefined} [compileOptions]\n *   Compile configuration (optional).\n * @return {Promise<VFile>}\n *   Promise to compiled file.\n */\nexport function compile(vfileCompatible, compileOptions) {\n  const {file, options} = resolveFileAndOptions(vfileCompatible, compileOptions)\n  return createProcessor(options).process(file)\n}\n\n/**\n * Synchronously compile MDX to JS.\n *\n * When possible please use the async `compile`.\n *\n * @param {Readonly<Compatible>} vfileCompatible\n *   MDX document to parse.\n * @param {Readonly<CompileOptions> | null | undefined} [compileOptions]\n *   Compile configuration (optional).\n * @return {VFile}\n *   Compiled file.\n */\nexport function compileSync(vfileCompatible, compileOptions) {\n  const {file, options} = resolveFileAndOptions(vfileCompatible, compileOptions)\n  return createProcessor(options).processSync(file)\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC,GAED;;;;;;;;;;;;;;;;CAgBC;;;;;;;;;AAeM,SAAS,QAAQ,eAAe,EAAE,cAAc;IACrD,MAAM,EAAC,IAAI,EAAE,OAAO,EAAC,GAAG,wQAAsB,iBAAiB;IAC/D,OAAO,6NAAgB,SAAS,OAAO,CAAC;AAC1C;AAcO,SAAS,YAAY,eAAe,EAAE,cAAc;IACzD,MAAM,EAAC,IAAI,EAAE,OAAO,EAAC,GAAG,wQAAsB,iBAAiB;IAC/D,OAAO,6NAAgB,SAAS,WAAW,CAAC;AAC9C"}},
    {"offset": {"line": 2359, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2364, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/util/resolve-evaluate-options.js"],"sourcesContent":["/**\n * @typedef {import('hast-util-to-jsx-runtime').Fragment} Fragment\n * @typedef {import('hast-util-to-jsx-runtime').Jsx} Jsx\n * @typedef {import('hast-util-to-jsx-runtime').JsxDev} JsxDev\n * @typedef {import('mdx/types.js').MDXComponents} Components\n * @typedef {import('../compile.js').CompileOptions} CompileOptions\n */\n\n/**\n * @typedef {EvaluateProcessorOptions & RunOptions} EvaluateOptions\n *   Configuration for `evaluate`.\n *\n * @typedef {Omit<CompileOptions, 'baseUrl' | 'jsx' | 'jsxImportSource' | 'jsxRuntime' | 'outputFormat' | 'pragma' | 'pragmaFrag' | 'pragmaImportSource' | 'providerImportSource'> } EvaluateProcessorOptions\n *   Compile configuration without JSX options for evaluation.\n *\n * @typedef RunOptions\n *   Configuration to run compiled code.\n *\n *   `Fragment`, `jsx`, and `jsxs` are used when the code is compiled in\n *   production mode (`development: false`).\n *   `Fragment` and `jsxDEV` are used when compiled in development mode\n *   (`development: true`).\n *   `useMDXComponents` is used when the code is compiled with\n *   `providerImportSource: '#'` (the exact value of this compile option\n *   doesn’t matter).\n * @property {URL | string | null | undefined} [baseUrl]\n *   Use this URL as `import.meta.url` and resolve `import` and `export … from`\n *   relative to it (optional, example: `import.meta.url`);\n *   this option can also be given at compile time in `CompileOptions`;\n *   you should pass this (likely at runtime), as you might get runtime errors\n *   when using `import.meta.url` / `import` / `export … from ` otherwise.\n * @property {Fragment} Fragment\n *   Symbol to use for fragments (**required**).\n * @property {Jsx | null | undefined} [jsx]\n *   Function to generate an element with static children in production mode.\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Function to generate an element in development mode.\n * @property {Jsx | null | undefined} [jsxs]\n *   Function to generate an element with dynamic children in production mode.\n * @property {UseMdxComponents | null | undefined} [useMDXComponents]\n *   Function to get components from context.\n *\n * @callback UseMdxComponents\n *   Get components from context.\n * @returns {Components}\n *   Current components.\n */\n\n// Fix to show references to above types in VS Code.\n''\n\n/**\n * Split compiletime options from runtime options.\n *\n * @param {Readonly<EvaluateOptions> | null | undefined} options\n *   Configuration.\n * @returns {{compiletime: CompileOptions, runtime: RunOptions}}\n *   Split options.\n */\nexport function resolveEvaluateOptions(options) {\n  const {\n    Fragment,\n    baseUrl,\n    development,\n    jsx,\n    jsxDEV,\n    jsxs,\n    useMDXComponents,\n    ...rest\n  } = options || {}\n\n  if (!Fragment) throw new Error('Expected `Fragment` given to `evaluate`')\n  if (development) {\n    if (!jsxDEV) throw new Error('Expected `jsxDEV` given to `evaluate`')\n  } else {\n    if (!jsx) throw new Error('Expected `jsx` given to `evaluate`')\n    if (!jsxs) throw new Error('Expected `jsxs` given to `evaluate`')\n  }\n\n  return {\n    compiletime: {\n      ...rest,\n      development,\n      outputFormat: 'function-body',\n      providerImportSource: useMDXComponents ? '#' : undefined\n    },\n    runtime: {Fragment, baseUrl, jsx, jsxDEV, jsxs, useMDXComponents}\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsCC,GAED,oDAAoD;;;;AACpD;AAUO,SAAS,uBAAuB,OAAO;IAC5C,MAAM,EACJ,QAAQ,EACR,OAAO,EACP,WAAW,EACX,GAAG,EACH,MAAM,EACN,IAAI,EACJ,gBAAgB,EAChB,GAAG,MACJ,GAAG,WAAW,CAAC;IAEhB,IAAI,CAAC,UAAU,MAAM,IAAI,MAAM;IAC/B,IAAI,aAAa;QACf,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;IAC/B,OAAO;QACL,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;QAC1B,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAC7B;IAEA,OAAO;QACL,aAAa;YACX,GAAG,IAAI;YACP;YACA,cAAc;YACd,sBAAsB,mBAAmB,MAAM;QACjD;QACA,SAAS;YAAC;YAAU;YAAS;YAAK;YAAQ;YAAM;QAAgB;IAClE;AACF"}},
    {"offset": {"line": 2439, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2444, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/lib/evaluate.js"],"sourcesContent":["/**\n * @typedef {import('mdx/types.js').MDXModule} MDXModule\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('./util/resolve-evaluate-options.js').EvaluateOptions} EvaluateOptions\n */\n\nimport {resolveEvaluateOptions} from './util/resolve-evaluate-options.js'\nimport {compile, compileSync} from './compile.js'\nimport {run, runSync} from './run.js'\n\n/**\n * Compile and run MDX.\n *\n * When you trust your content, `evaluate` can work.\n * When possible, use `compile`, write to a file, and then run with Node or use\n * one of the integrations.\n *\n * > ☢️ **Danger**: it’s called **evaluate** because it `eval`s JavaScript.\n *\n * ###### Notes\n *\n * Compiling (and running) MDX takes time.\n *\n * If you are live-rendering a string of MDX that often changes using a virtual\n * DOM based framework (such as React), one performance improvement is to call\n * the `MDXContent` component yourself.\n * The reason is that the `evaluate` creates a new function each time, which\n * cannot be diffed:\n *\n * ```diff\n *  const {default: MDXContent} = await evaluate('…')\n *\n * -<MDXContent {...props} />\n * +MDXContent(props)\n * ```\n *\n * @param {Readonly<Compatible>} file\n *   MDX document to parse.\n * @param {Readonly<EvaluateOptions>} options\n *   Configuration (**required**).\n * @return {Promise<MDXModule>}\n *   Promise to a module;\n *   the result is an object with a `default` field set to the component;\n *   anything else that was exported is available too.\n\n */\nexport async function evaluate(file, options) {\n  const {compiletime, runtime} = resolveEvaluateOptions(options)\n  return run(await compile(file, compiletime), runtime)\n}\n\n/**\n * Compile and run MDX, synchronously.\n *\n * When possible please use the async `evaluate`.\n *\n * > ☢️ **Danger**: it’s called **evaluate** because it `eval`s JavaScript.\n *\n * @param {Readonly<Compatible>} file\n *   MDX document to parse.\n * @param {Readonly<EvaluateOptions>} options\n *   Configuration (**required**).\n * @return {MDXModule}\n *   Module.\n */\nexport function evaluateSync(file, options) {\n  const {compiletime, runtime} = resolveEvaluateOptions(options)\n  return runSync(compileSync(file, compiletime), runtime)\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;;;;AA0CM,eAAe,SAAS,IAAI,EAAE,OAAO;IAC1C,MAAM,EAAC,WAAW,EAAE,OAAO,EAAC,GAAG,sQAAuB;IACtD,OAAO,gNAAI,MAAM,wNAAQ,MAAM,cAAc;AAC/C;AAgBO,SAAS,aAAa,IAAI,EAAE,OAAO;IACxC,MAAM,EAAC,WAAW,EAAE,OAAO,EAAC,GAAG,sQAAuB;IACtD,OAAO,oNAAQ,4NAAY,MAAM,cAAc;AACjD"}},
    {"offset": {"line": 2467, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2472, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@3.0.0/node_modules/@mdx-js/mdx/index.js"],"sourcesContent":["/**\n * @typedef {import('./lib/util/resolve-evaluate-options.js').Fragment} Fragment\n * @typedef {import('./lib/util/resolve-evaluate-options.js').Jsx} Jsx\n * @typedef {import('./lib/util/resolve-evaluate-options.js').JsxDev} JsxDev\n * @typedef {import('./lib/util/resolve-evaluate-options.js').UseMdxComponents} UseMdxComponents\n * @typedef {import('./lib/compile.js').CompileOptions} CompileOptions\n * @typedef {import('./lib/core.js').ProcessorOptions} ProcessorOptions\n * @typedef {import('./lib/evaluate.js').EvaluateOptions} EvaluateOptions\n * @typedef {import('./lib/run.js').RunOptions} RunOptions\n */\n\nexport {compile, compileSync} from './lib/compile.js'\nexport {createProcessor} from './lib/core.js'\nexport {evaluate, evaluateSync} from './lib/evaluate.js'\nexport {nodeTypes} from './lib/node-types.js'\nexport {run, runSync} from './lib/run.js'\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC"}},
    {"offset": {"line": 2502, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2507, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/node-types.js"],"sourcesContent":["/**\n * List of node types made by `mdast-util-mdx`, which have to be passed\n * through untouched from the mdast tree to the hast tree.\n */\nexport const nodeTypes = [\n  'mdxFlowExpression',\n  'mdxJsxFlowElement',\n  'mdxJsxTextElement',\n  'mdxTextExpression',\n  'mdxjsEsm'\n]\n"],"names":[],"mappings":"AAAA;;;CAGC;;;AACM,MAAM,YAAY;IACvB;IACA;IACA;IACA;IACA;CACD"}},
    {"offset": {"line": 2520, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2525, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/run.js"],"sourcesContent":["/** @type {new (code: string, ...args: Array<unknown>) => Function} **/\nconst AsyncFunction = Object.getPrototypeOf(run).constructor\n\n/**\n * Asynchronously run code.\n *\n * @param {{toString(): string}} file\n *   JS document to run.\n * @param {unknown} options\n *   Parameter.\n * @return {Promise<any>}\n *   Anthing.\n */\nexport async function run(file, options) {\n  return new AsyncFunction(String(file))(options)\n}\n\n/**\n * Synchronously run code.\n *\n * @param {{toString(): string}} file\n *   JS document to run.\n * @param {unknown} options\n *   Parameter.\n * @return {any}\n *   Anthing.\n */\nexport function runSync(file, options) {\n  // eslint-disable-next-line no-new-func\n  return new Function(String(file))(options)\n}\n"],"names":[],"mappings":"AAAA,qEAAqE;;;;AACrE,MAAM,gBAAgB,OAAO,cAAc,CAAC,KAAK,WAAW;AAYrD,eAAe,IAAI,IAAI,EAAE,OAAO;IACrC,OAAO,IAAI,cAAc,OAAO,OAAO;AACzC;AAYO,SAAS,QAAQ,IAAI,EAAE,OAAO;IACnC,uCAAuC;IACvC,OAAO,IAAI,SAAS,OAAO,OAAO;AACpC"}},
    {"offset": {"line": 2537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2542, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/resolve-evaluate-options.js"],"sourcesContent":["/**\n * @typedef {import('../core.js').ProcessorOptions} ProcessorOptions\n *\n * @typedef RunnerOptions\n *   Configuration with JSX runtime.\n * @property {any} Fragment\n *   Symbol to use for fragments.\n * @property {any} [jsx]\n *   Function to generate an element with static children in production mode.\n * @property {any} [jsxs]\n *   Function to generate an element with dynamic children in production mode.\n * @property {any} [jsxDEV]\n *   Function to generate an element in development mode.\n * @property {any} [useMDXComponents]\n *   Function to get `MDXComponents` from context.\n *\n * @typedef {Omit<ProcessorOptions, 'jsx' | 'jsxImportSource' | 'jsxRuntime' | 'pragma' | 'pragmaFrag' | 'pragmaImportSource' | 'providerImportSource' | 'outputFormat'> } EvaluateProcessorOptions\n *   Compile configuration without JSX options for evaluation.\n *\n * @typedef {EvaluateProcessorOptions & RunnerOptions} EvaluateOptions\n *   Configuration for evaluation.\n */\n\n/**\n * Split compiletime options from runtime options.\n *\n * @param {EvaluateOptions | null | undefined} options\n * @returns {{compiletime: ProcessorOptions, runtime: RunnerOptions}}\n */\nexport function resolveEvaluateOptions(options) {\n  const {development, Fragment, jsx, jsxs, jsxDEV, useMDXComponents, ...rest} =\n    options || {}\n\n  if (!Fragment) throw new Error('Expected `Fragment` given to `evaluate`')\n  if (development) {\n    if (!jsxDEV) throw new Error('Expected `jsxDEV` given to `evaluate`')\n  } else {\n    if (!jsx) throw new Error('Expected `jsx` given to `evaluate`')\n    if (!jsxs) throw new Error('Expected `jsxs` given to `evaluate`')\n  }\n\n  return {\n    compiletime: {\n      ...rest,\n      development,\n      outputFormat: 'function-body',\n      providerImportSource: useMDXComponents ? '#' : undefined\n    },\n    runtime: {Fragment, jsx, jsxs, jsxDEV, useMDXComponents}\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;CAqBC,GAED;;;;;CAKC;;;AACM,SAAS,uBAAuB,OAAO;IAC5C,MAAM,EAAC,WAAW,EAAE,QAAQ,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,gBAAgB,EAAE,GAAG,MAAK,GACzE,WAAW,CAAC;IAEd,IAAI,CAAC,UAAU,MAAM,IAAI,MAAM;IAC/B,IAAI,aAAa;QACf,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;IAC/B,OAAO;QACL,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;QAC1B,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAC7B;IAEA,OAAO;QACL,aAAa;YACX,GAAG,IAAI;YACP;YACA,cAAc;YACd,sBAAsB,mBAAmB,MAAM;QACjD;QACA,SAAS;YAAC;YAAU;YAAK;YAAM;YAAQ;QAAgB;IACzD;AACF"}},
    {"offset": {"line": 2596, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2601, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/extnames.js"],"sourcesContent":["// @ts-expect-error: untyped.\nimport markdownExtensions from 'markdown-extensions'\n\nexport const mdx = ['.mdx']\n/** @type {Array<string>} */\nexport const md = markdownExtensions.map((/** @type {string} */ d) => '.' + d)\n"],"names":[],"mappings":"AAAA,6BAA6B;;;;;;;;AAGtB,MAAM,MAAM;IAAC;CAAO;AAEpB,MAAM,KAAK,uNAAmB,GAAG,CAAC,CAAC,mBAAmB,GAAG,IAAM,MAAM"}},
    {"offset": {"line": 2613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2618, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/resolve-file-and-options.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('../core.js').ProcessorOptions} ProcessorOptions\n * @typedef {import('../compile.js').CompileOptions} CompileOptions\n */\n\nimport {VFile} from 'vfile'\nimport {md} from './extnames.js'\n\n/**\n * Create a file and options from a given `vfileCompatible` and options that\n * might contain `format: 'detect'`.\n *\n * @param {VFileCompatible} vfileCompatible\n * @param {CompileOptions | null | undefined} [options]\n * @returns {{file: VFile, options: ProcessorOptions}}\n */\nexport function resolveFileAndOptions(vfileCompatible, options) {\n  const file = looksLikeAVFile(vfileCompatible)\n    ? vfileCompatible\n    : new VFile(vfileCompatible)\n  const {format, ...rest} = options || {}\n  return {\n    file,\n    options: {\n      format:\n        format === 'md' || format === 'mdx'\n          ? format\n          : file.extname && (rest.mdExtensions || md).includes(file.extname)\n          ? 'md'\n          : 'mdx',\n      ...rest\n    }\n  }\n}\n\n/**\n * @param {VFileCompatible | null | undefined} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;AAaM,SAAS,sBAAsB,eAAe,EAAE,OAAO;IAC5D,MAAM,OAAO,gBAAgB,mBACzB,kBACA,uLAAU;IACd,MAAM,EAAC,MAAM,EAAE,GAAG,MAAK,GAAG,WAAW,CAAC;IACtC,OAAO;QACL;QACA,SAAS;YACP,QACE,WAAW,QAAQ,WAAW,QAC1B,SACA,KAAK,OAAO,IAAI,CAAC,KAAK,YAAY,+NAAM,EAAE,QAAQ,CAAC,KAAK,OAAO,IAC/D,OACA;YACN,GAAG,IAAI;QACT;IACF;AACF;AAEA;;;CAGC,GACD,SAAS,gBAAgB,KAAK;IAC5B,OAAO,QACL,SACE,OAAO,UAAU,YACjB,aAAa,SACb,cAAc;AAEpB"}},
    {"offset": {"line": 2647, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2652, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/condition.js"],"sourcesContent":["import process from 'process'\n\nexport const development = process.env.NODE_ENV === 'development'\n"],"names":[],"mappings":";;;;;;AAEO,MAAM,cAAc,4CAAQ,GAAG,CAAC,QAAQ,KAAK"}},
    {"offset": {"line": 2659, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2664, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/plugin/remark-mark-and-unravel.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('remark-mdx')} DoNotTouchAsThisImportItIncludesMdxInTree\n */\n\nimport {visit} from 'unist-util-visit'\n\n/**\n * A tiny plugin that unravels `<p><h1>x</h1></p>` but also\n * `<p><Component /></p>` (so it has no knowledge of “HTML”).\n *\n * It also marks JSX as being explicitly JSX, so when a user passes a `h1`\n * component, it is used for `# heading` but not for `<h1>heading</h1>`.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport function remarkMarkAndUnravel() {\n  return (tree) => {\n    visit(tree, (node, index, parent) => {\n      let offset = -1\n      let all = true\n      let oneOrMore = false\n\n      if (parent && typeof index === 'number' && node.type === 'paragraph') {\n        const children = node.children\n\n        while (++offset < children.length) {\n          const child = children[offset]\n\n          if (\n            child.type === 'mdxJsxTextElement' ||\n            child.type === 'mdxTextExpression'\n          ) {\n            oneOrMore = true\n          } else if (\n            child.type === 'text' &&\n            /^[\\t\\r\\n ]+$/.test(String(child.value))\n          ) {\n            // Empty.\n          } else {\n            all = false\n            break\n          }\n        }\n\n        if (all && oneOrMore) {\n          offset = -1\n\n          /** @type {Array<Content>} */\n          const newChildren = []\n\n          while (++offset < children.length) {\n            const child = children[offset]\n\n            if (child.type === 'mdxJsxTextElement') {\n              // @ts-expect-error: content model is fine.\n              child.type = 'mdxJsxFlowElement'\n            }\n\n            if (child.type === 'mdxTextExpression') {\n              // @ts-expect-error: content model is fine.\n              child.type = 'mdxFlowExpression'\n            }\n\n            if (\n              child.type === 'text' &&\n              /^[\\t\\r\\n ]+$/.test(String(child.value))\n            ) {\n              // Empty.\n            } else {\n              newChildren.push(child)\n            }\n          }\n\n          parent.children.splice(index, 1, ...newChildren)\n          return index\n        }\n      }\n\n      if (\n        node.type === 'mdxJsxFlowElement' ||\n        node.type === 'mdxJsxTextElement'\n      ) {\n        const data = node.data || (node.data = {})\n        data._mdxExplicitJsx = true\n      }\n    })\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;AAaM,SAAS;IACd,OAAO,CAAC;QACN,qNAAM,MAAM,CAAC,MAAM,OAAO;YACxB,IAAI,SAAS,CAAC;YACd,IAAI,MAAM;YACV,IAAI,YAAY;YAEhB,IAAI,UAAU,OAAO,UAAU,YAAY,KAAK,IAAI,KAAK,aAAa;gBACpE,MAAM,WAAW,KAAK,QAAQ;gBAE9B,MAAO,EAAE,SAAS,SAAS,MAAM,CAAE;oBACjC,MAAM,QAAQ,QAAQ,CAAC,OAAO;oBAE9B,IACE,MAAM,IAAI,KAAK,uBACf,MAAM,IAAI,KAAK,qBACf;wBACA,YAAY;oBACd,OAAO,IACL,MAAM,IAAI,KAAK,UACf,eAAe,IAAI,CAAC,OAAO,MAAM,KAAK,IACtC;oBACA,SAAS;oBACX,OAAO;wBACL,MAAM;wBACN;oBACF;gBACF;gBAEA,IAAI,OAAO,WAAW;oBACpB,SAAS,CAAC;oBAEV,2BAA2B,GAC3B,MAAM,cAAc,EAAE;oBAEtB,MAAO,EAAE,SAAS,SAAS,MAAM,CAAE;wBACjC,MAAM,QAAQ,QAAQ,CAAC,OAAO;wBAE9B,IAAI,MAAM,IAAI,KAAK,qBAAqB;4BACtC,2CAA2C;4BAC3C,MAAM,IAAI,GAAG;wBACf;wBAEA,IAAI,MAAM,IAAI,KAAK,qBAAqB;4BACtC,2CAA2C;4BAC3C,MAAM,IAAI,GAAG;wBACf;wBAEA,IACE,MAAM,IAAI,KAAK,UACf,eAAe,IAAI,CAAC,OAAO,MAAM,KAAK,IACtC;wBACA,SAAS;wBACX,OAAO;4BACL,YAAY,IAAI,CAAC;wBACnB;oBACF;oBAEA,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO,MAAM;oBACpC,OAAO;gBACT;YACF;YAEA,IACE,KAAK,IAAI,KAAK,uBACd,KAAK,IAAI,KAAK,qBACd;gBACA,MAAM,OAAO,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC;gBACzC,KAAK,eAAe,GAAG;YACzB;QACF;IACF;AACF"}},
    {"offset": {"line": 2724, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2729, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/plugin/rehype-remove-raw.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('mdast-util-to-hast')} DoNotRemoveUsedToAddRawToNodeType\n */\n\nimport {visit} from 'unist-util-visit'\n\n/**\n * A tiny plugin that removes raw HTML.\n *\n * This is needed if the format is `md` and `rehype-raw` was not used to parse\n * dangerous HTML into nodes.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport function rehypeRemoveRaw() {\n  return (tree) => {\n    visit(tree, 'raw', (_, index, parent) => {\n      if (parent && typeof index === 'number') {\n        parent.children.splice(index, 1)\n        return index\n      }\n    })\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAYM,SAAS;IACd,OAAO,CAAC;QACN,qNAAM,MAAM,OAAO,CAAC,GAAG,OAAO;YAC5B,IAAI,UAAU,OAAO,UAAU,UAAU;gBACvC,OAAO,QAAQ,CAAC,MAAM,CAAC,OAAO;gBAC9B,OAAO;YACT;QACF;IACF;AACF"}},
    {"offset": {"line": 2748, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2753, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/plugin/rehype-recma.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Specify casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef Options\n *   Configuration for internal plugin `rehype-recma`.\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names.\n *\n *   This casing is used for hast elements, not for embedded MDX JSX nodes\n *   (components that someone authored manually).\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects.\n *\n *   This casing is used for hast elements, not for embedded MDX JSX nodes\n *   (components that someone authored manually).\n */\n\nimport {toEstree} from 'hast-util-to-estree'\n\n/**\n * A plugin to transform an HTML (hast) tree to a JS (estree).\n * `hast-util-to-estree` does all the work for us!\n *\n * @type {import('unified').Plugin<[Options | null | undefined] | [], Root, Program>}\n */\nexport function rehypeRecma(options) {\n  return (tree) => toEstree(tree, options)\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;CAyBC;;;;;;AAUM,SAAS,YAAY,OAAO;IACjC,OAAO,CAAC,OAAS,oOAAS,MAAM;AAClC"}},
    {"offset": {"line": 2790, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2795, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/plugin/recma-stringify.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {typeof import('source-map').SourceMapGenerator} SourceMapGenerator\n *\n * @typedef RecmaStringifyOptions\n *   Configuration for internal plugin `recma-stringify`.\n * @property {SourceMapGenerator | null | undefined} [SourceMapGenerator]\n *   Generate a source map by passing a `SourceMapGenerator` from `source-map`\n *   in.\n */\n\nimport {toJs, jsx} from 'estree-util-to-js'\n\n/**\n * A plugin that adds an esast compiler: a small wrapper around `astring` to add\n * support for serializing JSX.\n *\n * @this {import('unified').Processor}\n * @type {import('unified').Plugin<[RecmaStringifyOptions | null | undefined] | [], Program, string>}\n */\nexport function recmaStringify(options) {\n  // Always given inside `@mdx-js/mdx`\n  /* c8 ignore next */\n  const {SourceMapGenerator} = options || {}\n\n  Object.assign(this, {Compiler: compiler})\n\n  /** @type {import('unified').CompilerFunction<Program, string>} */\n  function compiler(tree, file) {\n    const result = SourceMapGenerator\n      ? toJs(tree, {\n          filePath: file.path || 'unknown.mdx',\n          SourceMapGenerator,\n          handlers: jsx\n        })\n      : toJs(tree, {handlers: jsx})\n\n    file.map = result.map\n\n    return result.value\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AAWM,SAAS,eAAe,OAAO;IACpC,oCAAoC;IACpC,kBAAkB,GAClB,MAAM,EAAC,kBAAkB,EAAC,GAAG,WAAW,CAAC;IAEzC,OAAO,MAAM,CAAC,IAAI,EAAE;QAAC,UAAU;IAAQ;IAEvC,gEAAgE,GAChE,SAAS,SAAS,IAAI,EAAE,IAAI;QAC1B,MAAM,SAAS,qBACX,4NAAK,MAAM;YACT,UAAU,KAAK,IAAI,IAAI;YACvB;YACA,QAAQ;QACV,KACA,4NAAK,MAAM;YAAC,QAAQ;QAAK;QAE7B,KAAK,GAAG,GAAG,OAAO,GAAG;QAErB,OAAO,OAAO,KAAK;IACrB;AACF"}},
    {"offset": {"line": 2828, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2833, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/estree-util-to-binary-addition.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Expression} Expression\n */\n\n/**\n * @param {Array<Expression>} expressions\n */\nexport function toBinaryAddition(expressions) {\n  let index = -1\n  /** @type {Expression | undefined} */\n  let left\n\n  while (++index < expressions.length) {\n    const right = expressions[index]\n    left = left ? {type: 'BinaryExpression', left, operator: '+', right} : right\n  }\n\n  // Just for types.\n  /* c8 ignore next */\n  if (!left) throw new Error('Expected non-empty `expressions` to be passed')\n\n  return left\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;CAEC;;;AACM,SAAS,iBAAiB,WAAW;IAC1C,IAAI,QAAQ,CAAC;IACb,mCAAmC,GACnC,IAAI;IAEJ,MAAO,EAAE,QAAQ,YAAY,MAAM,CAAE;QACnC,MAAM,QAAQ,WAAW,CAAC,MAAM;QAChC,OAAO,OAAO;YAAC,MAAM;YAAoB;YAAM,UAAU;YAAK;QAAK,IAAI;IACzE;IAEA,kBAAkB;IAClB,kBAAkB,GAClB,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAE3B,OAAO;AACT"}},
    {"offset": {"line": 2856, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2861, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/estree-util-to-id-or-member-expression.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').JSXIdentifier} JSXIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JSXMemberExpression\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').MemberExpression} MemberExpression\n */\n\nimport {\n  start as esStart,\n  cont as esCont,\n  name as isIdentifierName\n} from 'estree-util-is-identifier-name'\n\nexport const toIdOrMemberExpression = toIdOrMemberExpressionFactory(\n  'Identifier',\n  'MemberExpression',\n  isIdentifierName\n)\n\nexport const toJsxIdOrMemberExpression =\n  // @ts-expect-error: fine\n  /** @type {(ids: Array<string | number>) => JSXIdentifier | JSXMemberExpression)} */\n  (\n    toIdOrMemberExpressionFactory(\n      'JSXIdentifier',\n      'JSXMemberExpression',\n      isJsxIdentifierName\n    )\n  )\n\n/**\n * @param {string} idType\n * @param {string} memberType\n * @param {(value: string) => boolean} isIdentifier\n */\nfunction toIdOrMemberExpressionFactory(idType, memberType, isIdentifier) {\n  return toIdOrMemberExpression\n  /**\n   * @param {Array<string | number>} ids\n   * @returns {Identifier | MemberExpression}\n   */\n  function toIdOrMemberExpression(ids) {\n    let index = -1\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let object\n\n    while (++index < ids.length) {\n      const name = ids[index]\n      const valid = typeof name === 'string' && isIdentifier(name)\n\n      // A value of `asd.123` could be turned into `asd['123']` in the JS form,\n      // but JSX does not have a form for it, so throw.\n      /* c8 ignore next 3 */\n      if (idType === 'JSXIdentifier' && !valid) {\n        throw new Error('Cannot turn `' + name + '` into a JSX identifier')\n      }\n\n      /** @type {Identifier | Literal} */\n      // @ts-expect-error: JSX is fine.\n      const id = valid ? {type: idType, name} : {type: 'Literal', value: name}\n      // @ts-expect-error: JSX is fine.\n      object = object\n        ? {\n            type: memberType,\n            object,\n            property: id,\n            computed: id.type === 'Literal',\n            optional: false\n          }\n        : id\n    }\n\n    // Just for types.\n    /* c8 ignore next 3 */\n    if (!object) throw new Error('Expected non-empty `ids` to be passed')\n    if (object.type === 'Literal')\n      throw new Error('Expected identifier as left-most value')\n\n    return object\n  }\n}\n\n/**\n * Checks if the given string is a valid JSX identifier name.\n * @param {string} name\n */\nfunction isJsxIdentifierName(name) {\n  let index = -1\n\n  while (++index < name.length) {\n    // We currently receive valid input, but this catches bugs and is needed\n    // when externalized.\n    /* c8 ignore next */\n    if (!(index ? jsxCont : esStart)(name.charCodeAt(index))) return false\n  }\n\n  // `false` if `name` is empty.\n  return index > 0\n}\n\n/**\n * Checks if the given character code can continue a JSX identifier.\n * @param {number} code\n */\nfunction jsxCont(code) {\n  return code === 45 /* `-` */ || esCont(code)\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;AAQM,MAAM,yBAAyB,8BACpC,cACA;AAIK,MAAM,4BAIT,8BACE,iBACA,uBACA;AAIN;;;;CAIC,GACD,SAAS,8BAA8B,MAAM,EAAE,UAAU,EAAE,YAAY;IACrE,OAAO;IACP;;;GAGC,GACD,SAAS,uBAAuB,GAAG;QACjC,IAAI,QAAQ,CAAC;QACb,gEAAgE,GAChE,IAAI;QAEJ,MAAO,EAAE,QAAQ,IAAI,MAAM,CAAE;YAC3B,MAAM,OAAO,GAAG,CAAC,MAAM;YACvB,MAAM,QAAQ,OAAO,SAAS,YAAY,aAAa;YAEvD,yEAAyE;YACzE,iDAAiD;YACjD,oBAAoB,GACpB,IAAI,WAAW,mBAAmB,CAAC,OAAO;gBACxC,MAAM,IAAI,MAAM,kBAAkB,OAAO;YAC3C;YAEA,iCAAiC,GACjC,iCAAiC;YACjC,MAAM,KAAK,QAAQ;gBAAC,MAAM;gBAAQ;YAAI,IAAI;gBAAC,MAAM;gBAAW,OAAO;YAAI;YACvE,iCAAiC;YACjC,SAAS,SACL;gBACE,MAAM;gBACN;gBACA,UAAU;gBACV,UAAU,GAAG,IAAI,KAAK;gBACtB,UAAU;YACZ,IACA;QACN;QAEA,kBAAkB;QAClB,oBAAoB,GACpB,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;QAC7B,IAAI,OAAO,IAAI,KAAK,WAClB,MAAM,IAAI,MAAM;QAElB,OAAO;IACT;AACF;AAEA;;;CAGC,GACD,SAAS,oBAAoB,IAAI;IAC/B,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,KAAK,MAAM,CAAE;QAC5B,wEAAwE;QACxE,qBAAqB;QACrB,kBAAkB,GAClB,IAAI,CAAC,CAAC,QAAQ,sQAAiB,EAAE,KAAK,UAAU,CAAC,SAAS,OAAO;IACnE;IAEA,8BAA8B;IAC9B,OAAO,QAAQ;AACjB;AAEA;;;CAGC,GACD,SAAS,QAAQ,IAAI;IACnB,OAAO,SAAS,GAAG,OAAO,OAAM,4PAAO;AACzC"}},
    {"offset": {"line": 2938, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2943, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/estree-util-create.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Node} Node\n */\n\n/**\n * @param {Node} from\n *   Node to take from.\n * @param {Node} to\n *   Node to add to.\n * @returns {void}\n *   Nothing.\n */\nexport function create(from, to) {\n  /** @type {Array<keyof Node>} */\n  // @ts-expect-error: `start`, `end`, `comments` are custom Acorn fields.\n  const fields = ['start', 'end', 'loc', 'range', 'comments']\n  let index = -1\n\n  while (++index < fields.length) {\n    const field = fields[index]\n\n    if (field in from) {\n      // @ts-expect-error: assume they’re settable.\n      to[field] = from[field]\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAED;;;;;;;CAOC;;;AACM,SAAS,OAAO,IAAI,EAAE,EAAE;IAC7B,8BAA8B,GAC9B,wEAAwE;IACxE,MAAM,SAAS;QAAC;QAAS;QAAO;QAAO;QAAS;KAAW;IAC3D,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,OAAO,MAAM,CAAE;QAC9B,MAAM,QAAQ,MAAM,CAAC,MAAM;QAE3B,IAAI,SAAS,MAAM;YACjB,6CAA6C;YAC7C,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM;QACzB;IACF;AACF"}},
    {"offset": {"line": 2973, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2978, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/estree-util-specifiers-to-declarations.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').AssignmentProperty} AssignmentProperty\n * @typedef {import('estree-jsx').ExportSpecifier} ExportSpecifier\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportDefaultSpecifier} ImportDefaultSpecifier\n * @typedef {import('estree-jsx').ImportNamespaceSpecifier} ImportNamespaceSpecifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').VariableDeclarator} VariableDeclarator\n */\n\nimport {create} from './estree-util-create.js'\n\n/**\n * @param {Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier>} specifiers\n * @param {Expression} init\n * @returns {Array<VariableDeclarator>}\n */\nexport function specifiersToDeclarations(specifiers, init) {\n  let index = -1\n  /** @type {Array<VariableDeclarator>} */\n  const declarations = []\n  /** @type {Array<ImportSpecifier | ImportDefaultSpecifier | ExportSpecifier>} */\n  const otherSpecifiers = []\n  // Can only be one according to JS syntax.\n  /** @type {ImportNamespaceSpecifier | undefined} */\n  let importNamespaceSpecifier\n\n  while (++index < specifiers.length) {\n    const specifier = specifiers[index]\n\n    if (specifier.type === 'ImportNamespaceSpecifier') {\n      importNamespaceSpecifier = specifier\n    } else {\n      otherSpecifiers.push(specifier)\n    }\n  }\n\n  if (importNamespaceSpecifier) {\n    /** @type {VariableDeclarator} */\n    const declarator = {\n      type: 'VariableDeclarator',\n      id: importNamespaceSpecifier.local,\n      init\n    }\n    create(importNamespaceSpecifier, declarator)\n    declarations.push(declarator)\n  }\n\n  declarations.push({\n    type: 'VariableDeclarator',\n    id: {\n      type: 'ObjectPattern',\n      properties: otherSpecifiers.map((specifier) => {\n        /** @type {Identifier} */\n        let key =\n          specifier.type === 'ImportSpecifier'\n            ? specifier.imported\n            : specifier.type === 'ExportSpecifier'\n            ? specifier.exported\n            : {type: 'Identifier', name: 'default'}\n        let value = specifier.local\n\n        // Switch them around if we’re exporting.\n        if (specifier.type === 'ExportSpecifier') {\n          value = key\n          key = specifier.local\n        }\n\n        /** @type {AssignmentProperty} */\n        const property = {\n          type: 'Property',\n          kind: 'init',\n          shorthand: key.name === value.name,\n          method: false,\n          computed: false,\n          key,\n          value\n        }\n        create(specifier, property)\n        return property\n      })\n    },\n    init: importNamespaceSpecifier\n      ? {type: 'Identifier', name: importNamespaceSpecifier.local.name}\n      : init\n  })\n\n  return declarations\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AASM,SAAS,yBAAyB,UAAU,EAAE,IAAI;IACvD,IAAI,QAAQ,CAAC;IACb,sCAAsC,GACtC,MAAM,eAAe,EAAE;IACvB,8EAA8E,GAC9E,MAAM,kBAAkB,EAAE;IAC1B,0CAA0C;IAC1C,iDAAiD,GACjD,IAAI;IAEJ,MAAO,EAAE,QAAQ,WAAW,MAAM,CAAE;QAClC,MAAM,YAAY,UAAU,CAAC,MAAM;QAEnC,IAAI,UAAU,IAAI,KAAK,4BAA4B;YACjD,2BAA2B;QAC7B,OAAO;YACL,gBAAgB,IAAI,CAAC;QACvB;IACF;IAEA,IAAI,0BAA0B;QAC5B,+BAA+B,GAC/B,MAAM,aAAa;YACjB,MAAM;YACN,IAAI,yBAAyB,KAAK;YAClC;QACF;QACA,gPAAO,0BAA0B;QACjC,aAAa,IAAI,CAAC;IACpB;IAEA,aAAa,IAAI,CAAC;QAChB,MAAM;QACN,IAAI;YACF,MAAM;YACN,YAAY,gBAAgB,GAAG,CAAC,CAAC;gBAC/B,uBAAuB,GACvB,IAAI,MACF,UAAU,IAAI,KAAK,oBACf,UAAU,QAAQ,GAClB,UAAU,IAAI,KAAK,oBACnB,UAAU,QAAQ,GAClB;oBAAC,MAAM;oBAAc,MAAM;gBAAS;gBAC1C,IAAI,QAAQ,UAAU,KAAK;gBAE3B,yCAAyC;gBACzC,IAAI,UAAU,IAAI,KAAK,mBAAmB;oBACxC,QAAQ;oBACR,MAAM,UAAU,KAAK;gBACvB;gBAEA,+BAA+B,GAC/B,MAAM,WAAW;oBACf,MAAM;oBACN,MAAM;oBACN,WAAW,IAAI,IAAI,KAAK,MAAM,IAAI;oBAClC,QAAQ;oBACR,UAAU;oBACV;oBACA;gBACF;gBACA,gPAAO,WAAW;gBAClB,OAAO;YACT;QACF;QACA,MAAM,2BACF;YAAC,MAAM;YAAc,MAAM,yBAAyB,KAAK,CAAC,IAAI;QAAA,IAC9D;IACN;IAEA,OAAO;AACT"}},
    {"offset": {"line": 3051, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3056, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/plugin/recma-jsx-rewrite.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').Function} EstreeFunction\n * @typedef {import('estree-jsx').Identifier} Identifier\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').JSXElement} JSXElement\n * @typedef {import('estree-jsx').ModuleDeclaration} ModuleDeclaration\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').ObjectPattern} ObjectPattern\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').Statement} Statement\n * @typedef {import('estree-jsx').VariableDeclarator} VariableDeclarator\n *\n * @typedef {import('periscopic').Scope & {node: Node}} Scope\n */\n\n/**\n * @typedef RecmaJsxRewriteOptions\n *   Configuration for internal plugin `recma-jsx-rewrite`.\n * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']\n *   Whether to use an import statement or `arguments[0]` to get the provider.\n * @property {string | null | undefined} [providerImportSource]\n *   Place to import a provider from.\n * @property {boolean | null | undefined} [development=false]\n *   Whether to add extra info to error messages in generated code.\n *\n *   This also results in the development automatic JSX runtime\n *   (`/jsx-dev-runtime`, `jsxDEV`) being used, which passes positional info to\n *   nodes.\n *   The default can be set to `true` in Node.js through environment variables:\n *   set `NODE_ENV=development`.\n *\n * @typedef StackEntry\n * @property {Array<string>} objects\n * @property {Array<string>} components\n * @property {Array<string>} tags\n * @property {Record<string, {node: JSXElement, component: boolean}>} references\n * @property {Map<string|number, string>} idToInvalidComponentName\n * @property {EstreeFunction} node\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\nimport {positionFromEstree} from 'unist-util-position-from-estree'\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\nimport {walk} from 'estree-walker'\nimport {analyze} from 'periscopic'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {\n  toIdOrMemberExpression,\n  toJsxIdOrMemberExpression\n} from '../util/estree-util-to-id-or-member-expression.js'\nimport {toBinaryAddition} from '../util/estree-util-to-binary-addition.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * A plugin that rewrites JSX in functions to accept components as\n * `props.components` (when the function is called `_createMdxContent`), or from\n * a provider (if there is one).\n * It also makes sure that any undefined components are defined: either from\n * received components or as a function that throws an error.\n *\n * @type {import('unified').Plugin<[RecmaJsxRewriteOptions | null | undefined] | [], Program>}\n */\nexport function recmaJsxRewrite(options) {\n  // Always given inside `@mdx-js/mdx`\n  /* c8 ignore next */\n  const {development, providerImportSource, outputFormat} = options || {}\n\n  return (tree, file) => {\n    // Find everything that’s defined in the top-level scope.\n    const scopeInfo = analyze(tree)\n    /** @type {Array<StackEntry>} */\n    const fnStack = []\n    let importProvider = false\n    let createErrorHelper = false\n    /** @type {Scope | undefined} */\n    let currentScope\n\n    walk(tree, {\n      enter(node) {\n        const newScope = /** @type {Scope | undefined} */ (\n          scopeInfo.map.get(node)\n        )\n\n        if (\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression' ||\n          node.type === 'ArrowFunctionExpression'\n        ) {\n          fnStack.push({\n            objects: [],\n            components: [],\n            tags: [],\n            references: {},\n            idToInvalidComponentName: new Map(),\n            node\n          })\n\n          // MDXContent only ever contains MDXLayout\n          if (\n            isNamedFunction(node, 'MDXContent') &&\n            newScope &&\n            !inScope(newScope, 'MDXLayout')\n          ) {\n            fnStack[0].components.push('MDXLayout')\n          }\n        }\n\n        const fnScope = fnStack[0]\n        if (\n          !fnScope ||\n          (!isNamedFunction(fnScope.node, '_createMdxContent') &&\n            !providerImportSource)\n        ) {\n          return\n        }\n\n        if (newScope) {\n          newScope.node = node\n          currentScope = newScope\n        }\n\n        if (currentScope && node.type === 'JSXElement') {\n          let name = node.openingElement.name\n\n          // `<x.y>`, `<Foo.Bar>`, `<x.y.z>`.\n          if (name.type === 'JSXMemberExpression') {\n            /** @type {Array<string>} */\n            const ids = []\n\n            // Find the left-most identifier.\n            while (name.type === 'JSXMemberExpression') {\n              ids.unshift(name.property.name)\n              name = name.object\n            }\n\n            ids.unshift(name.name)\n            const fullId = ids.join('.')\n            const id = name.name\n\n            const isInScope = inScope(currentScope, id)\n\n            if (!own.call(fnScope.references, fullId)) {\n              const parentScope = /** @type {Scope | undefined} */ (\n                currentScope.parent\n              )\n              if (\n                !isInScope ||\n                // If the parent scope is `_createMdxContent`, then this\n                // references a component we can add a check statement for.\n                (parentScope &&\n                  parentScope.node.type === 'FunctionDeclaration' &&\n                  isNamedFunction(parentScope.node, '_createMdxContent'))\n              ) {\n                fnScope.references[fullId] = {node, component: true}\n              }\n            }\n\n            if (!fnScope.objects.includes(id) && !isInScope) {\n              fnScope.objects.push(id)\n            }\n          }\n          // `<xml:thing>`.\n          else if (name.type === 'JSXNamespacedName') {\n            // Ignore namespaces.\n          }\n          // If the name is a valid ES identifier, and it doesn’t start with a\n          // lowercase letter, it’s a component.\n          // For example, `$foo`, `_bar`, `Baz` are all component names.\n          // But `foo` and `b-ar` are tag names.\n          else if (isIdentifierName(name.name) && !/^[a-z]/.test(name.name)) {\n            const id = name.name\n\n            if (!inScope(currentScope, id)) {\n              // No need to add an error for an undefined layout — we use an\n              // `if` later.\n              if (id !== 'MDXLayout' && !own.call(fnScope.references, id)) {\n                fnScope.references[id] = {node, component: true}\n              }\n\n              if (!fnScope.components.includes(id)) {\n                fnScope.components.push(id)\n              }\n            }\n          }\n          // @ts-expect-error Allow fields passed through from mdast through hast to\n          // esast.\n          else if (node.data && node.data._mdxExplicitJsx) {\n            // Do not turn explicit JSX into components from `_components`.\n            // As in, a given `h1` component is used for `# heading` (next case),\n            // but not for `<h1>heading</h1>`.\n          } else {\n            const id = name.name\n\n            if (!fnScope.tags.includes(id)) {\n              fnScope.tags.push(id)\n            }\n\n            /** @type {Array<string | number>} */\n            let jsxIdExpression = ['_components', id]\n            if (isIdentifierName(id) === false) {\n              let invalidComponentName =\n                fnScope.idToInvalidComponentName.get(id)\n              if (invalidComponentName === undefined) {\n                invalidComponentName = `_component${fnScope.idToInvalidComponentName.size}`\n                fnScope.idToInvalidComponentName.set(id, invalidComponentName)\n              }\n\n              jsxIdExpression = [invalidComponentName]\n            }\n\n            node.openingElement.name =\n              toJsxIdOrMemberExpression(jsxIdExpression)\n\n            if (node.closingElement) {\n              node.closingElement.name =\n                toJsxIdOrMemberExpression(jsxIdExpression)\n            }\n          }\n        }\n      },\n      leave(node) {\n        /** @type {Array<Property>} */\n        const defaults = []\n        /** @type {Array<string>} */\n        const actual = []\n        /** @type {Array<Expression>} */\n        const parameters = []\n        /** @type {Array<VariableDeclarator>} */\n        const declarations = []\n\n        if (currentScope && currentScope.node === node) {\n          // @ts-expect-error: `node`s were patched when entering.\n          currentScope = currentScope.parent\n        }\n\n        if (\n          node.type === 'FunctionDeclaration' ||\n          node.type === 'FunctionExpression' ||\n          node.type === 'ArrowFunctionExpression'\n        ) {\n          const fn = node\n          const scope = fnStack[fnStack.length - 1]\n          /** @type {string} */\n          let name\n\n          for (name of scope.tags) {\n            defaults.push({\n              type: 'Property',\n              kind: 'init',\n              key: isIdentifierName(name)\n                ? {type: 'Identifier', name}\n                : {type: 'Literal', value: name},\n              value: {type: 'Literal', value: name},\n              method: false,\n              shorthand: false,\n              computed: false\n            })\n          }\n\n          actual.push(...scope.components)\n\n          for (name of scope.objects) {\n            // In some cases, a component is used directly (`<X>`) but it’s also\n            // used as an object (`<X.Y>`).\n            if (!actual.includes(name)) {\n              actual.push(name)\n            }\n          }\n\n          /** @type {Array<Statement>} */\n          const statements = []\n\n          if (\n            defaults.length > 0 ||\n            actual.length > 0 ||\n            scope.idToInvalidComponentName.size > 0\n          ) {\n            if (providerImportSource) {\n              importProvider = true\n              parameters.push({\n                type: 'CallExpression',\n                callee: {type: 'Identifier', name: '_provideComponents'},\n                arguments: [],\n                optional: false\n              })\n            }\n\n            // Accept `components` as a prop if this is the `MDXContent` or\n            // `_createMdxContent` function.\n            if (\n              isNamedFunction(scope.node, 'MDXContent') ||\n              isNamedFunction(scope.node, '_createMdxContent')\n            ) {\n              parameters.push(toIdOrMemberExpression(['props', 'components']))\n            }\n\n            if (defaults.length > 0 || parameters.length > 1) {\n              parameters.unshift({\n                type: 'ObjectExpression',\n                properties: defaults\n              })\n            }\n\n            // If we’re getting components from several sources, merge them.\n            /** @type {Expression} */\n            let componentsInit =\n              parameters.length > 1\n                ? {\n                    type: 'CallExpression',\n                    callee: toIdOrMemberExpression(['Object', 'assign']),\n                    arguments: parameters,\n                    optional: false\n                  }\n                : parameters[0].type === 'MemberExpression'\n                ? // If we’re only getting components from `props.components`,\n                  // make sure it’s defined.\n                  {\n                    type: 'LogicalExpression',\n                    operator: '||',\n                    left: parameters[0],\n                    right: {type: 'ObjectExpression', properties: []}\n                  }\n                : parameters[0]\n\n            /** @type {ObjectPattern | undefined} */\n            let componentsPattern\n\n            // Add components to scope.\n            // For `['MyComponent', 'MDXLayout']` this generates:\n            // ```js\n            // const {MyComponent, wrapper: MDXLayout} = _components\n            // ```\n            // Note that MDXLayout is special as it’s taken from\n            // `_components.wrapper`.\n            if (actual.length > 0) {\n              componentsPattern = {\n                type: 'ObjectPattern',\n                properties: actual.map((name) => ({\n                  type: 'Property',\n                  kind: 'init',\n                  key: {\n                    type: 'Identifier',\n                    name: name === 'MDXLayout' ? 'wrapper' : name\n                  },\n                  value: {type: 'Identifier', name},\n                  method: false,\n                  shorthand: name !== 'MDXLayout',\n                  computed: false\n                }))\n              }\n            }\n\n            if (scope.tags.length > 0) {\n              declarations.push({\n                type: 'VariableDeclarator',\n                id: {type: 'Identifier', name: '_components'},\n                init: componentsInit\n              })\n              componentsInit = {type: 'Identifier', name: '_components'}\n            }\n\n            if (isNamedFunction(scope.node, '_createMdxContent')) {\n              for (const [\n                id,\n                componentName\n              ] of scope.idToInvalidComponentName) {\n                // For JSX IDs that can’t be represented as JavaScript IDs (as in,\n                // those with dashes, such as `custom-element`), generate a\n                // separate variable that is a valid JS ID (such as `_component0`),\n                // and takes it from components:\n                // `const _component0 = _components['custom-element']`\n                declarations.push({\n                  type: 'VariableDeclarator',\n                  id: {type: 'Identifier', name: componentName},\n                  init: {\n                    type: 'MemberExpression',\n                    object: {type: 'Identifier', name: '_components'},\n                    property: {type: 'Literal', value: id},\n                    computed: true,\n                    optional: false\n                  }\n                })\n              }\n            }\n\n            if (componentsPattern) {\n              declarations.push({\n                type: 'VariableDeclarator',\n                id: componentsPattern,\n                init: componentsInit\n              })\n            }\n\n            if (declarations.length > 0) {\n              statements.push({\n                type: 'VariableDeclaration',\n                kind: 'const',\n                declarations\n              })\n            }\n          }\n\n          /** @type {string} */\n          let key\n\n          // Add partials (so for `x.y.z` it’d generate `x` and `x.y` too).\n          for (key in scope.references) {\n            if (own.call(scope.references, key)) {\n              const parts = key.split('.')\n              let index = 0\n              while (++index < parts.length) {\n                const partial = parts.slice(0, index).join('.')\n                if (!own.call(scope.references, partial)) {\n                  scope.references[partial] = {\n                    node: scope.references[key].node,\n                    component: false\n                  }\n                }\n              }\n            }\n          }\n\n          const references = Object.keys(scope.references).sort()\n          let index = -1\n          while (++index < references.length) {\n            const id = references[index]\n            const info = scope.references[id]\n            const place = stringifyPosition(positionFromEstree(info.node))\n            /** @type {Array<Expression>} */\n            const parameters = [\n              {type: 'Literal', value: id},\n              {type: 'Literal', value: info.component}\n            ]\n\n            createErrorHelper = true\n\n            if (development && place !== '1:1-1:1') {\n              parameters.push({type: 'Literal', value: place})\n            }\n\n            statements.push({\n              type: 'IfStatement',\n              test: {\n                type: 'UnaryExpression',\n                operator: '!',\n                prefix: true,\n                argument: toIdOrMemberExpression(id.split('.'))\n              },\n              consequent: {\n                type: 'ExpressionStatement',\n                expression: {\n                  type: 'CallExpression',\n                  callee: {type: 'Identifier', name: '_missingMdxReference'},\n                  arguments: parameters,\n                  optional: false\n                }\n              },\n              alternate: null\n            })\n          }\n\n          if (statements.length > 0) {\n            // Arrow functions with an implied return:\n            if (fn.body.type !== 'BlockStatement') {\n              fn.body = {\n                type: 'BlockStatement',\n                body: [{type: 'ReturnStatement', argument: fn.body}]\n              }\n            }\n\n            fn.body.body.unshift(...statements)\n          }\n\n          fnStack.pop()\n        }\n      }\n    })\n\n    // If a provider is used (and can be used), import it.\n    if (importProvider && providerImportSource) {\n      tree.body.unshift(\n        createImportProvider(providerImportSource, outputFormat)\n      )\n    }\n\n    // If potentially missing components are used.\n    if (createErrorHelper) {\n      /** @type {Array<Expression>} */\n      const message = [\n        {type: 'Literal', value: 'Expected '},\n        {\n          type: 'ConditionalExpression',\n          test: {type: 'Identifier', name: 'component'},\n          consequent: {type: 'Literal', value: 'component'},\n          alternate: {type: 'Literal', value: 'object'}\n        },\n        {type: 'Literal', value: ' `'},\n        {type: 'Identifier', name: 'id'},\n        {\n          type: 'Literal',\n          value:\n            '` to be defined: you likely forgot to import, pass, or provide it.'\n        }\n      ]\n\n      /** @type {Array<Identifier>} */\n      const parameters = [\n        {type: 'Identifier', name: 'id'},\n        {type: 'Identifier', name: 'component'}\n      ]\n\n      if (development) {\n        message.push({\n          type: 'ConditionalExpression',\n          test: {type: 'Identifier', name: 'place'},\n          consequent: toBinaryAddition([\n            {type: 'Literal', value: '\\nIt’s referenced in your code at `'},\n            {type: 'Identifier', name: 'place'},\n            {\n              type: 'Literal',\n              value: (file.path ? '` in `' + file.path : '') + '`'\n            }\n          ]),\n          alternate: {type: 'Literal', value: ''}\n        })\n\n        parameters.push({type: 'Identifier', name: 'place'})\n      }\n\n      tree.body.push({\n        type: 'FunctionDeclaration',\n        id: {type: 'Identifier', name: '_missingMdxReference'},\n        generator: false,\n        async: false,\n        params: parameters,\n        body: {\n          type: 'BlockStatement',\n          body: [\n            {\n              type: 'ThrowStatement',\n              argument: {\n                type: 'NewExpression',\n                callee: {type: 'Identifier', name: 'Error'},\n                arguments: [toBinaryAddition(message)]\n              }\n            }\n          ]\n        }\n      })\n    }\n  }\n}\n\n/**\n * @param {string} providerImportSource\n * @param {RecmaJsxRewriteOptions['outputFormat']} outputFormat\n * @returns {Statement | ModuleDeclaration}\n */\nfunction createImportProvider(providerImportSource, outputFormat) {\n  /** @type {Array<ImportSpecifier>} */\n  const specifiers = [\n    {\n      type: 'ImportSpecifier',\n      imported: {type: 'Identifier', name: 'useMDXComponents'},\n      local: {type: 'Identifier', name: '_provideComponents'}\n    }\n  ]\n\n  return outputFormat === 'function-body'\n    ? {\n        type: 'VariableDeclaration',\n        kind: 'const',\n        declarations: specifiersToDeclarations(\n          specifiers,\n          toIdOrMemberExpression(['arguments', 0])\n        )\n      }\n    : {\n        type: 'ImportDeclaration',\n        specifiers,\n        source: {type: 'Literal', value: providerImportSource}\n      }\n}\n\n/**\n * @param {EstreeFunction} node\n * @param {string} name\n * @returns {boolean}\n */\nfunction isNamedFunction(node, name) {\n  return Boolean(node && 'id' in node && node.id && node.id.name === name)\n}\n\n/**\n * @param {Scope} scope\n * @param {string} id\n * @returns {boolean}\n */\nfunction inScope(scope, id) {\n  /** @type {Scope | undefined} */\n  let currentScope = scope\n\n  while (currentScope) {\n    if (currentScope.declarations.has(id)) {\n      return true\n    }\n\n    // @ts-expect-error: `node`s have been added when entering.\n    currentScope = currentScope.parent\n  }\n\n  return false\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3646, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3651, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/estree-util-is-declaration.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').Declaration} Declaration\n */\n\n/**\n * Check if `node` is a declaration.\n *\n * @param {Node} node\n *   Node to check.\n * @returns {node is Declaration}\n *   Whether `node` is a declaration.\n */\nexport function isDeclaration(node) {\n  return Boolean(\n    node.type === 'FunctionDeclaration' ||\n      node.type === 'ClassDeclaration' ||\n      node.type === 'VariableDeclaration'\n  )\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;;;;;CAOC;;;AACM,SAAS,cAAc,IAAI;IAChC,OAAO,QACL,KAAK,IAAI,KAAK,yBACZ,KAAK,IAAI,KAAK,sBACd,KAAK,IAAI,KAAK;AAEpB"}},
    {"offset": {"line": 3667, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3672, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/util/estree-util-declaration-to-expression.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Declaration} Declaration\n * @typedef {import('estree-jsx').Expression} Expression\n */\n\n/**\n * Turn a declaration into an expression.\n *\n * Doesn’t work for variable declarations, but that’s fine for our use case\n * because currently we’re using this utility for export default declarations,\n * which can’t contain variable declarations.\n *\n * @param {Declaration} declaration\n *   Declaration.\n * @returns {Expression}\n *   Expression.\n */\nexport function declarationToExpression(declaration) {\n  if (declaration.type === 'FunctionDeclaration') {\n    return {...declaration, type: 'FunctionExpression'}\n  }\n\n  if (declaration.type === 'ClassDeclaration') {\n    return {...declaration, type: 'ClassExpression'}\n    /* Internal utility so the next shouldn’t happen or a maintainer is making a\n     * mistake. */\n    /* c8 ignore next 4 */\n  }\n\n  // Probably `VariableDeclaration`.\n  throw new Error('Cannot turn `' + declaration.type + '` into an expression')\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;;;;;;;;;CAWC;;;AACM,SAAS,wBAAwB,WAAW;IACjD,IAAI,YAAY,IAAI,KAAK,uBAAuB;QAC9C,OAAO;YAAC,GAAG,WAAW;YAAE,MAAM;QAAoB;IACpD;IAEA,IAAI,YAAY,IAAI,KAAK,oBAAoB;QAC3C,OAAO;YAAC,GAAG,WAAW;YAAE,MAAM;QAAiB;IAC/C;gBACY,GACZ,oBAAoB,GACtB;IAEA,kCAAkC;IAClC,MAAM,IAAI,MAAM,kBAAkB,YAAY,IAAI,GAAG;AACvD"}},
    {"offset": {"line": 3706, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3711, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/plugin/recma-document.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Directive} Directive\n * @typedef {import('estree-jsx').ExportAllDeclaration} ExportAllDeclaration\n * @typedef {import('estree-jsx').ExportDefaultDeclaration} ExportDefaultDeclaration\n * @typedef {import('estree-jsx').ExportNamedDeclaration} ExportNamedDeclaration\n * @typedef {import('estree-jsx').ExportSpecifier} ExportSpecifier\n * @typedef {import('estree-jsx').Expression} Expression\n * @typedef {import('estree-jsx').FunctionDeclaration} FunctionDeclaration\n * @typedef {import('estree-jsx').ImportDeclaration} ImportDeclaration\n * @typedef {import('estree-jsx').ImportDefaultSpecifier} ImportDefaultSpecifier\n * @typedef {import('estree-jsx').ImportExpression} ImportExpression\n * @typedef {import('estree-jsx').ImportSpecifier} ImportSpecifier\n * @typedef {import('estree-jsx').Literal} Literal\n * @typedef {import('estree-jsx').JSXElement} JSXElement\n * @typedef {import('estree-jsx').ModuleDeclaration} ModuleDeclaration\n * @typedef {import('estree-jsx').Node} Node\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('estree-jsx').Property} Property\n * @typedef {import('estree-jsx').SimpleLiteral} SimpleLiteral\n * @typedef {import('estree-jsx').SpreadElement} SpreadElement\n * @typedef {import('estree-jsx').Statement} Statement\n * @typedef {import('estree-jsx').VariableDeclarator} VariableDeclarator\n */\n\n/**\n * @typedef RecmaDocumentOptions\n *   Configuration for internal plugin `recma-document`.\n * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']\n *   Whether to use either `import` and `export` statements to get the runtime\n *   (and optionally provider) and export the content, or get values from\n *   `arguments` and return things.\n * @property {boolean | null | undefined} [useDynamicImport=false]\n *   Whether to keep `import` (and `export … from`) statements or compile them\n *   to dynamic `import()` instead.\n * @property {string | null | undefined} [baseUrl]\n *   Resolve `import`s (and `export … from`, and `import.meta.url`) relative to\n *   this URL.\n * @property {string | null | undefined} [pragma='React.createElement']\n *   Pragma for JSX (used in classic runtime).\n * @property {string | null | undefined} [pragmaFrag='React.Fragment']\n *   Pragma for JSX fragments (used in classic runtime).\n * @property {string | null | undefined} [pragmaImportSource='react']\n *   Where to import the identifier of `pragma` from (used in classic runtime).\n * @property {string | null | undefined} [jsxImportSource='react']\n *   Place to import automatic JSX runtimes from (used in automatic runtime).\n * @property {'automatic' | 'classic' | null | undefined} [jsxRuntime='automatic']\n *   JSX runtime to use.\n */\n\nimport {analyze} from 'periscopic'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nimport {positionFromEstree} from 'unist-util-position-from-estree'\nimport {walk} from 'estree-walker'\nimport {create} from '../util/estree-util-create.js'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {declarationToExpression} from '../util/estree-util-declaration-to-expression.js'\nimport {isDeclaration} from '../util/estree-util-is-declaration.js'\n\n/**\n * A plugin to wrap the estree in `MDXContent`.\n *\n * @type {import('unified').Plugin<[RecmaDocumentOptions | null | undefined] | [], Program>}\n */\nexport function recmaDocument(options) {\n  // Always given inside `@mdx-js/mdx`\n  /* c8 ignore next */\n  const options_ = options || {}\n  const baseUrl = options_.baseUrl || undefined\n  const useDynamicImport = options_.useDynamicImport || undefined\n  const outputFormat = options_.outputFormat || 'program'\n  const pragma =\n    options_.pragma === undefined ? 'React.createElement' : options_.pragma\n  const pragmaFrag =\n    options_.pragmaFrag === undefined ? 'React.Fragment' : options_.pragmaFrag\n  const pragmaImportSource = options_.pragmaImportSource || 'react'\n  const jsxImportSource = options_.jsxImportSource || 'react'\n  const jsxRuntime = options_.jsxRuntime || 'automatic'\n\n  return (tree, file) => {\n    /** @type {Array<[string, string] | string>} */\n    const exportedIdentifiers = []\n    /** @type {Array<Directive | ModuleDeclaration | Statement>} */\n    const replacement = []\n    /** @type {Array<string>} */\n    const pragmas = []\n    let exportAllCount = 0\n    /** @type {ExportDefaultDeclaration | ExportSpecifier | undefined} */\n    let layout\n    /** @type {boolean | undefined} */\n    let content\n    /** @type {Node} */\n    let child\n\n    // Patch missing comments, which types say could occur.\n    /* c8 ignore next */\n    if (!tree.comments) tree.comments = []\n\n    if (jsxRuntime) {\n      pragmas.push('@jsxRuntime ' + jsxRuntime)\n    }\n\n    if (jsxRuntime === 'automatic' && jsxImportSource) {\n      pragmas.push('@jsxImportSource ' + jsxImportSource)\n    }\n\n    if (jsxRuntime === 'classic' && pragma) {\n      pragmas.push('@jsx ' + pragma)\n    }\n\n    if (jsxRuntime === 'classic' && pragmaFrag) {\n      pragmas.push('@jsxFrag ' + pragmaFrag)\n    }\n\n    if (pragmas.length > 0) {\n      tree.comments.unshift({type: 'Block', value: pragmas.join(' ')})\n    }\n\n    if (jsxRuntime === 'classic' && pragmaImportSource) {\n      if (!pragma) {\n        throw new Error(\n          'Missing `pragma` in classic runtime with `pragmaImportSource`'\n        )\n      }\n\n      handleEsm({\n        type: 'ImportDeclaration',\n        specifiers: [\n          {\n            type: 'ImportDefaultSpecifier',\n            local: {type: 'Identifier', name: pragma.split('.')[0]}\n          }\n        ],\n        source: {type: 'Literal', value: pragmaImportSource}\n      })\n    }\n\n    // Find the `export default`, the JSX expression, and leave the rest\n    // (import/exports) as they are.\n    for (child of tree.body) {\n      // ```js\n      // export default props => <>{props.children}</>\n      // ```\n      //\n      // Treat it as an inline layout declaration.\n      if (child.type === 'ExportDefaultDeclaration') {\n        if (layout) {\n          file.fail(\n            'Cannot specify multiple layouts (previous: ' +\n              stringifyPosition(positionFromEstree(layout)) +\n              ')',\n            positionFromEstree(child),\n            'recma-document:duplicate-layout'\n          )\n        }\n\n        layout = child\n        replacement.push({\n          type: 'VariableDeclaration',\n          kind: 'const',\n          declarations: [\n            {\n              type: 'VariableDeclarator',\n              id: {type: 'Identifier', name: 'MDXLayout'},\n              init: isDeclaration(child.declaration)\n                ? declarationToExpression(child.declaration)\n                : child.declaration\n            }\n          ]\n        })\n      }\n      // ```js\n      // export {a, b as c} from 'd'\n      // ```\n      else if (child.type === 'ExportNamedDeclaration' && child.source) {\n        const source = /** @type {SimpleLiteral} */ (child.source)\n\n        // Remove `default` or `as default`, but not `default as`, specifier.\n        child.specifiers = child.specifiers.filter((specifier) => {\n          if (specifier.exported.name === 'default') {\n            if (layout) {\n              file.fail(\n                'Cannot specify multiple layouts (previous: ' +\n                  stringifyPosition(positionFromEstree(layout)) +\n                  ')',\n                positionFromEstree(child),\n                'recma-document:duplicate-layout'\n              )\n            }\n\n            layout = specifier\n\n            // Make it just an import: `import MDXLayout from '…'`.\n            /** @type {Array<ImportDefaultSpecifier | ImportSpecifier>} */\n            const specifiers = []\n\n            // Default as default / something else as default.\n            if (specifier.local.name === 'default') {\n              specifiers.push({\n                type: 'ImportDefaultSpecifier',\n                local: {type: 'Identifier', name: 'MDXLayout'}\n              })\n            } else {\n              /** @type {ImportSpecifier} */\n              const importSpecifier = {\n                type: 'ImportSpecifier',\n                imported: specifier.local,\n                local: {type: 'Identifier', name: 'MDXLayout'}\n              }\n              create(specifier.local, importSpecifier)\n              specifiers.push(importSpecifier)\n            }\n\n            /** @type {Literal} */\n            const from = {type: 'Literal', value: source.value}\n            create(source, from)\n\n            /** @type {ImportDeclaration} */\n            const declaration = {\n              type: 'ImportDeclaration',\n              specifiers,\n              source: from\n            }\n            create(specifier, declaration)\n            handleEsm(declaration)\n\n            return false\n          }\n\n          return true\n        })\n\n        // If there are other things imported, keep it.\n        if (child.specifiers.length > 0) {\n          handleExport(child)\n        }\n      }\n      // ```js\n      // export {a, b as c}\n      // export * from 'a'\n      // ```\n      else if (\n        child.type === 'ExportNamedDeclaration' ||\n        child.type === 'ExportAllDeclaration'\n      ) {\n        handleExport(child)\n      } else if (child.type === 'ImportDeclaration') {\n        handleEsm(child)\n      } else if (\n        child.type === 'ExpressionStatement' &&\n        // @ts-expect-error types are wrong: `JSXFragment` is an `Expression`.\n        (child.expression.type === 'JSXFragment' ||\n          child.expression.type === 'JSXElement')\n      ) {\n        content = true\n        replacement.push(...createMdxContent(child.expression, Boolean(layout)))\n        // The following catch-all branch is because plugins might’ve added\n        // other things.\n        // Normally, we only have import/export/jsx, but just add whatever’s\n        // there.\n        /* c8 ignore next 3 */\n      } else {\n        replacement.push(child)\n      }\n    }\n\n    // If there was no JSX content at all, add an empty function.\n    if (!content) {\n      replacement.push(...createMdxContent(undefined, Boolean(layout)))\n    }\n\n    exportedIdentifiers.push(['MDXContent', 'default'])\n\n    if (outputFormat === 'function-body') {\n      replacement.push({\n        type: 'ReturnStatement',\n        argument: {\n          type: 'ObjectExpression',\n          properties: [\n            ...Array.from({length: exportAllCount}).map(\n              /**\n               * @param {undefined} _\n               * @param {number} index\n               * @returns {SpreadElement}\n               */\n              (_, index) => ({\n                type: 'SpreadElement',\n                argument: {type: 'Identifier', name: '_exportAll' + (index + 1)}\n              })\n            ),\n            ...exportedIdentifiers.map((d) => {\n              /** @type {Property} */\n              const prop = {\n                type: 'Property',\n                kind: 'init',\n                method: false,\n                computed: false,\n                shorthand: typeof d === 'string',\n                key: {\n                  type: 'Identifier',\n                  name: typeof d === 'string' ? d : d[1]\n                },\n                value: {\n                  type: 'Identifier',\n                  name: typeof d === 'string' ? d : d[0]\n                }\n              }\n\n              return prop\n            })\n          ]\n        }\n      })\n    } else {\n      replacement.push({\n        type: 'ExportDefaultDeclaration',\n        declaration: {type: 'Identifier', name: 'MDXContent'}\n      })\n    }\n\n    tree.body = replacement\n\n    if (baseUrl) {\n      walk(tree, {\n        enter(node) {\n          if (\n            node.type === 'MemberExpression' &&\n            'object' in node &&\n            node.object.type === 'MetaProperty' &&\n            node.property.type === 'Identifier' &&\n            node.object.meta.name === 'import' &&\n            node.object.property.name === 'meta' &&\n            node.property.name === 'url'\n          ) {\n            /** @type {SimpleLiteral} */\n            const replacement = {type: 'Literal', value: baseUrl}\n            this.replace(replacement)\n          }\n        }\n      })\n    }\n\n    /**\n     * @param {ExportAllDeclaration | ExportNamedDeclaration} node\n     * @returns {void}\n     */\n    function handleExport(node) {\n      if (node.type === 'ExportNamedDeclaration') {\n        // ```js\n        // export function a() {}\n        // export class A {}\n        // export var a = 1\n        // ```\n        if (node.declaration) {\n          exportedIdentifiers.push(\n            ...analyze(node.declaration).scope.declarations.keys()\n          )\n        }\n\n        // ```js\n        // export {a, b as c}\n        // export {a, b as c} from 'd'\n        // ```\n        for (child of node.specifiers) {\n          exportedIdentifiers.push(child.exported.name)\n        }\n      }\n\n      handleEsm(node)\n    }\n\n    /**\n     * @param {ExportAllDeclaration | ExportNamedDeclaration | ImportDeclaration} node\n     * @returns {void}\n     */\n    function handleEsm(node) {\n      // Rewrite the source of the `import` / `export … from`.\n      // See: <https://html.spec.whatwg.org/multipage/webappapis.html#resolve-a-module-specifier>\n      if (baseUrl && node.source) {\n        let value = String(node.source.value)\n\n        try {\n          // A full valid URL.\n          value = String(new URL(value))\n        } catch {\n          // Relative: `/example.js`, `./example.js`, and `../example.js`.\n          if (/^\\.{0,2}\\//.test(value)) {\n            value = String(new URL(value, baseUrl))\n          }\n          // Otherwise, it’s a bare specifiers.\n          // For example `some-package`, `@some-package`, and\n          // `some-package/path`.\n          // These are supported in Node and browsers plan to support them\n          // with import maps (<https://github.com/WICG/import-maps>).\n        }\n\n        /** @type {Literal} */\n        const literal = {type: 'Literal', value}\n        create(node.source, literal)\n        node.source = literal\n      }\n\n      /** @type {ModuleDeclaration | Statement | undefined} */\n      let replace\n      /** @type {Expression} */\n      let init\n\n      if (outputFormat === 'function-body') {\n        if (\n          // Always have a source:\n          node.type === 'ImportDeclaration' ||\n          node.type === 'ExportAllDeclaration' ||\n          // Source optional:\n          (node.type === 'ExportNamedDeclaration' && node.source)\n        ) {\n          if (!useDynamicImport) {\n            file.fail(\n              'Cannot use `import` or `export … from` in `evaluate` (outputting a function body) by default: please set `useDynamicImport: true` (and probably specify a `baseUrl`)',\n              positionFromEstree(node),\n              'recma-document:invalid-esm-statement'\n            )\n          }\n\n          // Just for types.\n          /* c8 ignore next 3 */\n          if (!node.source) {\n            throw new Error('Expected `node.source` to be defined')\n          }\n\n          // ```\n          // import 'a'\n          // //=> await import('a')\n          // import a from 'b'\n          // //=> const {default: a} = await import('b')\n          // export {a, b as c} from 'd'\n          // //=> const {a, c: b} = await import('d')\n          // export * from 'a'\n          // //=> const _exportAll0 = await import('a')\n          // ```\n          /** @type {ImportExpression} */\n          const argument = {type: 'ImportExpression', source: node.source}\n          create(node, argument)\n          init = {type: 'AwaitExpression', argument}\n\n          if (\n            (node.type === 'ImportDeclaration' ||\n              node.type === 'ExportNamedDeclaration') &&\n            node.specifiers.length === 0\n          ) {\n            replace = {type: 'ExpressionStatement', expression: init}\n          } else {\n            replace = {\n              type: 'VariableDeclaration',\n              kind: 'const',\n              declarations:\n                node.type === 'ExportAllDeclaration'\n                  ? [\n                      {\n                        type: 'VariableDeclarator',\n                        id: {\n                          type: 'Identifier',\n                          name: '_exportAll' + ++exportAllCount\n                        },\n                        init\n                      }\n                    ]\n                  : specifiersToDeclarations(node.specifiers, init)\n            }\n          }\n        } else if (node.declaration) {\n          replace = node.declaration\n        } else {\n          /** @type {Array<VariableDeclarator>} */\n          const declarators = node.specifiers\n            .filter(\n              (specifier) => specifier.local.name !== specifier.exported.name\n            )\n            .map((specifier) => ({\n              type: 'VariableDeclarator',\n              id: specifier.exported,\n              init: specifier.local\n            }))\n\n          if (declarators.length > 0) {\n            replace = {\n              type: 'VariableDeclaration',\n              kind: 'const',\n              declarations: declarators\n            }\n          }\n        }\n      } else {\n        replace = node\n      }\n\n      if (replace) {\n        replacement.push(replace)\n      }\n    }\n  }\n\n  /**\n   * @param {Expression | undefined} [content]\n   * @param {boolean | undefined} [hasInternalLayout]\n   * @returns {Array<FunctionDeclaration>}\n   */\n  function createMdxContent(content, hasInternalLayout) {\n    /** @type {JSXElement} */\n    const element = {\n      type: 'JSXElement',\n      openingElement: {\n        type: 'JSXOpeningElement',\n        name: {type: 'JSXIdentifier', name: 'MDXLayout'},\n        attributes: [\n          {\n            type: 'JSXSpreadAttribute',\n            argument: {type: 'Identifier', name: 'props'}\n          }\n        ],\n        selfClosing: false\n      },\n      closingElement: {\n        type: 'JSXClosingElement',\n        name: {type: 'JSXIdentifier', name: 'MDXLayout'}\n      },\n      children: [\n        {\n          type: 'JSXElement',\n          openingElement: {\n            type: 'JSXOpeningElement',\n            name: {type: 'JSXIdentifier', name: '_createMdxContent'},\n            attributes: [\n              {\n                type: 'JSXSpreadAttribute',\n                argument: {type: 'Identifier', name: 'props'}\n              }\n            ],\n            selfClosing: true\n          },\n          closingElement: null,\n          children: []\n        }\n      ]\n    }\n\n    let result = /** @type {Expression} */ (element)\n\n    if (!hasInternalLayout) {\n      result = {\n        type: 'ConditionalExpression',\n        test: {type: 'Identifier', name: 'MDXLayout'},\n        consequent: result,\n        alternate: {\n          type: 'CallExpression',\n          callee: {type: 'Identifier', name: '_createMdxContent'},\n          arguments: [{type: 'Identifier', name: 'props'}],\n          optional: false\n        }\n      }\n    }\n\n    let argument = content || {type: 'Literal', value: null}\n\n    // Unwrap a fragment of a single element.\n    if (\n      argument &&\n      // @ts-expect-error: fine.\n      argument.type === 'JSXFragment' &&\n      // @ts-expect-error: fine.\n      argument.children.length === 1 &&\n      // @ts-expect-error: fine.\n      argument.children[0].type === 'JSXElement'\n    ) {\n      // @ts-expect-error: fine.\n      argument = argument.children[0]\n    }\n\n    return [\n      {\n        type: 'FunctionDeclaration',\n        id: {type: 'Identifier', name: '_createMdxContent'},\n        params: [{type: 'Identifier', name: 'props'}],\n        body: {\n          type: 'BlockStatement',\n          body: [{type: 'ReturnStatement', argument}]\n        }\n      },\n      {\n        type: 'FunctionDeclaration',\n        id: {type: 'Identifier', name: 'MDXContent'},\n        params: [\n          {\n            type: 'AssignmentPattern',\n            left: {type: 'Identifier', name: 'props'},\n            right: {type: 'ObjectExpression', properties: []}\n          }\n        ],\n        body: {\n          type: 'BlockStatement',\n          body: [{type: 'ReturnStatement', argument: result}]\n        }\n      }\n    ]\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;CAsBC,GAED;;;;;;;;;;;;;;;;;;;;;;;CAuBC;;;;;;;;;;;;;;;;;;;;AAgBM,SAAS,cAAc,OAAO;IACnC,oCAAoC;IACpC,kBAAkB,GAClB,MAAM,WAAW,WAAW,CAAC;IAC7B,MAAM,UAAU,SAAS,OAAO,IAAI;IACpC,MAAM,mBAAmB,SAAS,gBAAgB,IAAI;IACtD,MAAM,eAAe,SAAS,YAAY,IAAI;IAC9C,MAAM,SACJ,SAAS,MAAM,KAAK,YAAY,wBAAwB,SAAS,MAAM;IACzE,MAAM,aACJ,SAAS,UAAU,KAAK,YAAY,mBAAmB,SAAS,UAAU;IAC5E,MAAM,qBAAqB,SAAS,kBAAkB,IAAI;IAC1D,MAAM,kBAAkB,SAAS,eAAe,IAAI;IACpD,MAAM,aAAa,SAAS,UAAU,IAAI;IAE1C,OAAO,CAAC,MAAM;QACZ,6CAA6C,GAC7C,MAAM,sBAAsB,EAAE;QAC9B,6DAA6D,GAC7D,MAAM,cAAc,EAAE;QACtB,0BAA0B,GAC1B,MAAM,UAAU,EAAE;QAClB,IAAI,iBAAiB;QACrB,mEAAmE,GACnE,IAAI;QACJ,gCAAgC,GAChC,IAAI;QACJ,iBAAiB,GACjB,IAAI;QAEJ,uDAAuD;QACvD,kBAAkB,GAClB,IAAI,CAAC,KAAK,QAAQ,EAAE,KAAK,QAAQ,GAAG,EAAE;QAEtC,IAAI,YAAY;YACd,QAAQ,IAAI,CAAC,iBAAiB;QAChC;QAEA,IAAI,eAAe,eAAe,iBAAiB;YACjD,QAAQ,IAAI,CAAC,sBAAsB;QACrC;QAEA,IAAI,eAAe,aAAa,QAAQ;YACtC,QAAQ,IAAI,CAAC,UAAU;QACzB;QAEA,IAAI,eAAe,aAAa,YAAY;YAC1C,QAAQ,IAAI,CAAC,cAAc;QAC7B;QAEA,IAAI,QAAQ,MAAM,GAAG,GAAG;YACtB,KAAK,QAAQ,CAAC,OAAO,CAAC;gBAAC,MAAM;gBAAS,OAAO,QAAQ,IAAI,CAAC;YAAI;QAChE;QAEA,IAAI,eAAe,aAAa,oBAAoB;YAClD,IAAI,CAAC,QAAQ;gBACX,MAAM,IAAI,MACR;YAEJ;YAEA,UAAU;gBACR,MAAM;gBACN,YAAY;oBACV;wBACE,MAAM;wBACN,OAAO;4BAAC,MAAM;4BAAc,MAAM,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE;wBAAA;oBACxD;iBACD;gBACD,QAAQ;oBAAC,MAAM;oBAAW,OAAO;gBAAkB;YACrD;QACF;QAEA,oEAAoE;QACpE,gCAAgC;QAChC,KAAK,SAAS,KAAK,IAAI,CAAE;YACvB,QAAQ;YACR,gDAAgD;YAChD,MAAM;YACN,EAAE;YACF,4CAA4C;YAC5C,IAAI,MAAM,IAAI,KAAK,4BAA4B;gBAC7C,IAAI,QAAQ;oBACV,KAAK,IAAI,CACP,gDACE,iQAAkB,4QAAmB,WACrC,KACF,4QAAmB,QACnB;gBAEJ;gBAEA,SAAS;gBACT,YAAY,IAAI,CAAC;oBACf,MAAM;oBACN,MAAM;oBACN,cAAc;wBACZ;4BACE,MAAM;4BACN,IAAI;gCAAC,MAAM;gCAAc,MAAM;4BAAW;4BAC1C,MAAM,kQAAc,MAAM,WAAW,IACjC,0RAAwB,MAAM,WAAW,IACzC,MAAM,WAAW;wBACvB;qBACD;gBACH;YACF,OAIK,IAAI,MAAM,IAAI,KAAK,4BAA4B,MAAM,MAAM,EAAE;gBAChE,MAAM,SAAuC,MAAM,MAAM;gBAEzD,qEAAqE;gBACrE,MAAM,UAAU,GAAG,MAAM,UAAU,CAAC,MAAM,CAAC,CAAC;oBAC1C,IAAI,UAAU,QAAQ,CAAC,IAAI,KAAK,WAAW;wBACzC,IAAI,QAAQ;4BACV,KAAK,IAAI,CACP,gDACE,iQAAkB,4QAAmB,WACrC,KACF,4QAAmB,QACnB;wBAEJ;wBAEA,SAAS;wBAET,uDAAuD;wBACvD,4DAA4D,GAC5D,MAAM,aAAa,EAAE;wBAErB,kDAAkD;wBAClD,IAAI,UAAU,KAAK,CAAC,IAAI,KAAK,WAAW;4BACtC,WAAW,IAAI,CAAC;gCACd,MAAM;gCACN,OAAO;oCAAC,MAAM;oCAAc,MAAM;gCAAW;4BAC/C;wBACF,OAAO;4BACL,4BAA4B,GAC5B,MAAM,kBAAkB;gCACtB,MAAM;gCACN,UAAU,UAAU,KAAK;gCACzB,OAAO;oCAAC,MAAM;oCAAc,MAAM;gCAAW;4BAC/C;4BACA,gPAAO,UAAU,KAAK,EAAE;4BACxB,WAAW,IAAI,CAAC;wBAClB;wBAEA,oBAAoB,GACpB,MAAM,OAAO;4BAAC,MAAM;4BAAW,OAAO,OAAO,KAAK;wBAAA;wBAClD,gPAAO,QAAQ;wBAEf,8BAA8B,GAC9B,MAAM,cAAc;4BAClB,MAAM;4BACN;4BACA,QAAQ;wBACV;wBACA,gPAAO,WAAW;wBAClB,UAAU;wBAEV,OAAO;oBACT;oBAEA,OAAO;gBACT;gBAEA,+CAA+C;gBAC/C,IAAI,MAAM,UAAU,CAAC,MAAM,GAAG,GAAG;oBAC/B,aAAa;gBACf;YACF,OAKK,IACH,MAAM,IAAI,KAAK,4BACf,MAAM,IAAI,KAAK,wBACf;gBACA,aAAa;YACf,OAAO,IAAI,MAAM,IAAI,KAAK,qBAAqB;gBAC7C,UAAU;YACZ,OAAO,IACL,MAAM,IAAI,KAAK,yBACf,sEAAsE;YACtE,CAAC,MAAM,UAAU,CAAC,IAAI,KAAK,iBACzB,MAAM,UAAU,CAAC,IAAI,KAAK,YAAY,GACxC;gBACA,UAAU;gBACV,YAAY,IAAI,IAAI,iBAAiB,MAAM,UAAU,EAAE,QAAQ;YAC/D,mEAAmE;YACnE,gBAAgB;YAChB,oEAAoE;YACpE,SAAS;YACT,oBAAoB,GACtB,OAAO;gBACL,YAAY,IAAI,CAAC;YACnB;QACF;QAEA,6DAA6D;QAC7D,IAAI,CAAC,SAAS;YACZ,YAAY,IAAI,IAAI,iBAAiB,WAAW,QAAQ;QAC1D;QAEA,oBAAoB,IAAI,CAAC;YAAC;YAAc;SAAU;QAElD,IAAI,iBAAiB,iBAAiB;YACpC,YAAY,IAAI,CAAC;gBACf,MAAM;gBACN,UAAU;oBACR,MAAM;oBACN,YAAY;2BACP,MAAM,IAAI,CAAC;4BAAC,QAAQ;wBAAc,GAAG,GAAG,CACzC;;;;eAIC,GACD,CAAC,GAAG,QAAU,CAAC;gCACb,MAAM;gCACN,UAAU;oCAAC,MAAM;oCAAc,MAAM,eAAe,CAAC,QAAQ,CAAC;gCAAC;4BACjE,CAAC;2BAEA,oBAAoB,GAAG,CAAC,CAAC;4BAC1B,qBAAqB,GACrB,MAAM,OAAO;gCACX,MAAM;gCACN,MAAM;gCACN,QAAQ;gCACR,UAAU;gCACV,WAAW,OAAO,MAAM;gCACxB,KAAK;oCACH,MAAM;oCACN,MAAM,OAAO,MAAM,WAAW,IAAI,CAAC,CAAC,EAAE;gCACxC;gCACA,OAAO;oCACL,MAAM;oCACN,MAAM,OAAO,MAAM,WAAW,IAAI,CAAC,CAAC,EAAE;gCACxC;4BACF;4BAEA,OAAO;wBACT;qBACD;gBACH;YACF;QACF,OAAO;YACL,YAAY,IAAI,CAAC;gBACf,MAAM;gBACN,aAAa;oBAAC,MAAM;oBAAc,MAAM;gBAAY;YACtD;QACF;QAEA,KAAK,IAAI,GAAG;QAEZ,IAAI,SAAS;YACX,+MAAK,MAAM;gBACT,OAAM,IAAI;oBACR,IACE,KAAK,IAAI,KAAK,sBACd,YAAY,QACZ,KAAK,MAAM,CAAC,IAAI,KAAK,kBACrB,KAAK,QAAQ,CAAC,IAAI,KAAK,gBACvB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,KAAK,YAC1B,KAAK,MAAM,CAAC,QAAQ,CAAC,IAAI,KAAK,UAC9B,KAAK,QAAQ,CAAC,IAAI,KAAK,OACvB;wBACA,0BAA0B,GAC1B,MAAM,cAAc;4BAAC,MAAM;4BAAW,OAAO;wBAAO;wBACpD,IAAI,CAAC,OAAO,CAAC;oBACf;gBACF;YACF;QACF;QAEA;;;KAGC,GACD,SAAS,aAAa,IAAI;YACxB,IAAI,KAAK,IAAI,KAAK,0BAA0B;gBAC1C,QAAQ;gBACR,yBAAyB;gBACzB,oBAAoB;gBACpB,mBAAmB;gBACnB,MAAM;gBACN,IAAI,KAAK,WAAW,EAAE;oBACpB,oBAAoB,IAAI,IACnB,sMAAQ,KAAK,WAAW,EAAE,KAAK,CAAC,YAAY,CAAC,IAAI;gBAExD;gBAEA,QAAQ;gBACR,qBAAqB;gBACrB,8BAA8B;gBAC9B,MAAM;gBACN,KAAK,SAAS,KAAK,UAAU,CAAE;oBAC7B,oBAAoB,IAAI,CAAC,MAAM,QAAQ,CAAC,IAAI;gBAC9C;YACF;YAEA,UAAU;QACZ;QAEA;;;KAGC,GACD,SAAS,UAAU,IAAI;YACrB,wDAAwD;YACxD,2FAA2F;YAC3F,IAAI,WAAW,KAAK,MAAM,EAAE;gBAC1B,IAAI,QAAQ,OAAO,KAAK,MAAM,CAAC,KAAK;gBAEpC,IAAI;oBACF,oBAAoB;oBACpB,QAAQ,OAAO,IAAI,IAAI;gBACzB,EAAE,OAAM;oBACN,gEAAgE;oBAChE,IAAI,aAAa,IAAI,CAAC,QAAQ;wBAC5B,QAAQ,OAAO,IAAI,IAAI,OAAO;oBAChC;gBACA,qCAAqC;gBACrC,mDAAmD;gBACnD,uBAAuB;gBACvB,gEAAgE;gBAChE,4DAA4D;gBAC9D;gBAEA,oBAAoB,GACpB,MAAM,UAAU;oBAAC,MAAM;oBAAW;gBAAK;gBACvC,gPAAO,KAAK,MAAM,EAAE;gBACpB,KAAK,MAAM,GAAG;YAChB;YAEA,sDAAsD,GACtD,IAAI;YACJ,uBAAuB,GACvB,IAAI;YAEJ,IAAI,iBAAiB,iBAAiB;gBACpC,IACE,wBAAwB;gBACxB,KAAK,IAAI,KAAK,uBACd,KAAK,IAAI,KAAK,0BAEb,KAAK,IAAI,KAAK,4BAA4B,KAAK,MAAM,EACtD;oBACA,IAAI,CAAC,kBAAkB;wBACrB,KAAK,IAAI,CACP,wKACA,4QAAmB,OACnB;oBAEJ;oBAEA,kBAAkB;oBAClB,oBAAoB,GACpB,IAAI,CAAC,KAAK,MAAM,EAAE;wBAChB,MAAM,IAAI,MAAM;oBAClB;oBAEA,MAAM;oBACN,aAAa;oBACb,yBAAyB;oBACzB,oBAAoB;oBACpB,8CAA8C;oBAC9C,8BAA8B;oBAC9B,2CAA2C;oBAC3C,oBAAoB;oBACpB,6CAA6C;oBAC7C,MAAM;oBACN,6BAA6B,GAC7B,MAAM,WAAW;wBAAC,MAAM;wBAAoB,QAAQ,KAAK,MAAM;oBAAA;oBAC/D,gPAAO,MAAM;oBACb,OAAO;wBAAC,MAAM;wBAAmB;oBAAQ;oBAEzC,IACE,CAAC,KAAK,IAAI,KAAK,uBACb,KAAK,IAAI,KAAK,wBAAwB,KACxC,KAAK,UAAU,CAAC,MAAM,KAAK,GAC3B;wBACA,UAAU;4BAAC,MAAM;4BAAuB,YAAY;wBAAI;oBAC1D,OAAO;wBACL,UAAU;4BACR,MAAM;4BACN,MAAM;4BACN,cACE,KAAK,IAAI,KAAK,yBACV;gCACE;oCACE,MAAM;oCACN,IAAI;wCACF,MAAM;wCACN,MAAM,eAAe,EAAE;oCACzB;oCACA;gCACF;6BACD,GACD,4RAAyB,KAAK,UAAU,EAAE;wBAClD;oBACF;gBACF,OAAO,IAAI,KAAK,WAAW,EAAE;oBAC3B,UAAU,KAAK,WAAW;gBAC5B,OAAO;oBACL,sCAAsC,GACtC,MAAM,cAAc,KAAK,UAAU,CAChC,MAAM,CACL,CAAC,YAAc,UAAU,KAAK,CAAC,IAAI,KAAK,UAAU,QAAQ,CAAC,IAAI,EAEhE,GAAG,CAAC,CAAC,YAAc,CAAC;4BACnB,MAAM;4BACN,IAAI,UAAU,QAAQ;4BACtB,MAAM,UAAU,KAAK;wBACvB,CAAC;oBAEH,IAAI,YAAY,MAAM,GAAG,GAAG;wBAC1B,UAAU;4BACR,MAAM;4BACN,MAAM;4BACN,cAAc;wBAChB;oBACF;gBACF;YACF,OAAO;gBACL,UAAU;YACZ;YAEA,IAAI,SAAS;gBACX,YAAY,IAAI,CAAC;YACnB;QACF;IACF;IAEA;;;;GAIC,GACD,SAAS,iBAAiB,OAAO,EAAE,iBAAiB;QAClD,uBAAuB,GACvB,MAAM,UAAU;YACd,MAAM;YACN,gBAAgB;gBACd,MAAM;gBACN,MAAM;oBAAC,MAAM;oBAAiB,MAAM;gBAAW;gBAC/C,YAAY;oBACV;wBACE,MAAM;wBACN,UAAU;4BAAC,MAAM;4BAAc,MAAM;wBAAO;oBAC9C;iBACD;gBACD,aAAa;YACf;YACA,gBAAgB;gBACd,MAAM;gBACN,MAAM;oBAAC,MAAM;oBAAiB,MAAM;gBAAW;YACjD;YACA,UAAU;gBACR;oBACE,MAAM;oBACN,gBAAgB;wBACd,MAAM;wBACN,MAAM;4BAAC,MAAM;4BAAiB,MAAM;wBAAmB;wBACvD,YAAY;4BACV;gCACE,MAAM;gCACN,UAAU;oCAAC,MAAM;oCAAc,MAAM;gCAAO;4BAC9C;yBACD;wBACD,aAAa;oBACf;oBACA,gBAAgB;oBAChB,UAAU,EAAE;gBACd;aACD;QACH;QAEA,IAAI,SAAoC;QAExC,IAAI,CAAC,mBAAmB;YACtB,SAAS;gBACP,MAAM;gBACN,MAAM;oBAAC,MAAM;oBAAc,MAAM;gBAAW;gBAC5C,YAAY;gBACZ,WAAW;oBACT,MAAM;oBACN,QAAQ;wBAAC,MAAM;wBAAc,MAAM;oBAAmB;oBACtD,WAAW;wBAAC;4BAAC,MAAM;4BAAc,MAAM;wBAAO;qBAAE;oBAChD,UAAU;gBACZ;YACF;QACF;QAEA,IAAI,WAAW,WAAW;YAAC,MAAM;YAAW,OAAO;QAAI;QAEvD,yCAAyC;QACzC,IACE,YACA,0BAA0B;QAC1B,SAAS,IAAI,KAAK,iBAClB,0BAA0B;QAC1B,SAAS,QAAQ,CAAC,MAAM,KAAK,KAC7B,0BAA0B;QAC1B,SAAS,QAAQ,CAAC,EAAE,CAAC,IAAI,KAAK,cAC9B;YACA,0BAA0B;YAC1B,WAAW,SAAS,QAAQ,CAAC,EAAE;QACjC;QAEA,OAAO;YACL;gBACE,MAAM;gBACN,IAAI;oBAAC,MAAM;oBAAc,MAAM;gBAAmB;gBAClD,QAAQ;oBAAC;wBAAC,MAAM;wBAAc,MAAM;oBAAO;iBAAE;gBAC7C,MAAM;oBACJ,MAAM;oBACN,MAAM;wBAAC;4BAAC,MAAM;4BAAmB;wBAAQ;qBAAE;gBAC7C;YACF;YACA;gBACE,MAAM;gBACN,IAAI;oBAAC,MAAM;oBAAc,MAAM;gBAAY;gBAC3C,QAAQ;oBACN;wBACE,MAAM;wBACN,MAAM;4BAAC,MAAM;4BAAc,MAAM;wBAAO;wBACxC,OAAO;4BAAC,MAAM;4BAAoB,YAAY,EAAE;wBAAA;oBAClD;iBACD;gBACD,MAAM;oBACJ,MAAM;oBACN,MAAM;wBAAC;4BAAC,MAAM;4BAAmB,UAAU;wBAAM;qBAAE;gBACrD;YACF;SACD;IACH;AACF"}},
    {"offset": {"line": 4278, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4283, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/plugin/recma-jsx-build.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').Program} Program\n * @typedef {import('estree-util-build-jsx').BuildJsxOptions} BuildJsxOptions\n */\n\n/**\n * @typedef ExtraOptions\n *   Configuration for internal plugin `recma-jsx-build`.\n * @property {'function-body' | 'program' | null | undefined} [outputFormat='program']\n *   Whether to keep the import of the automatic runtime or get it from\n *   `arguments[0]` instead.\n *\n * @typedef {BuildJsxOptions & ExtraOptions} RecmaJsxBuildOptions\n */\n\nimport {buildJsx} from 'estree-util-build-jsx'\nimport {specifiersToDeclarations} from '../util/estree-util-specifiers-to-declarations.js'\nimport {toIdOrMemberExpression} from '../util/estree-util-to-id-or-member-expression.js'\n\n/**\n * A plugin to build JSX into function calls.\n * `estree-util-build-jsx` does all the work for us!\n *\n * @type {import('unified').Plugin<[RecmaJsxBuildOptions | null | undefined] | [], Program>}\n */\nexport function recmaJsxBuild(options) {\n  // Always given inside `@mdx-js/mdx`\n  /* c8 ignore next */\n  const {development, outputFormat} = options || {}\n\n  return (tree, file) => {\n    buildJsx(tree, {development, filePath: file.history[0]})\n\n    // When compiling to a function body, replace the import that was just\n    // generated, and get `jsx`, `jsxs`, and `Fragment` from `arguments[0]`\n    // instead.\n    if (\n      outputFormat === 'function-body' &&\n      tree.body[0] &&\n      tree.body[0].type === 'ImportDeclaration' &&\n      typeof tree.body[0].source.value === 'string' &&\n      /\\/jsx-(dev-)?runtime$/.test(tree.body[0].source.value)\n    ) {\n      tree.body[0] = {\n        type: 'VariableDeclaration',\n        kind: 'const',\n        declarations: specifiersToDeclarations(\n          tree.body[0].specifiers,\n          toIdOrMemberExpression(['arguments', 0])\n        )\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;;;;;;CAQC;;;;;;;;;;AAYM,SAAS,cAAc,OAAO;IACnC,oCAAoC;IACpC,kBAAkB,GAClB,MAAM,EAAC,WAAW,EAAE,YAAY,EAAC,GAAG,WAAW,CAAC;IAEhD,OAAO,CAAC,MAAM;QACZ,wOAAS,MAAM;YAAC;YAAa,UAAU,KAAK,OAAO,CAAC,EAAE;QAAA;QAEtD,sEAAsE;QACtE,uEAAuE;QACvE,WAAW;QACX,IACE,iBAAiB,mBACjB,KAAK,IAAI,CAAC,EAAE,IACZ,KAAK,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,uBACtB,OAAO,KAAK,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,KAAK,YACrC,wBAAwB,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,GACtD;YACA,KAAK,IAAI,CAAC,EAAE,GAAG;gBACb,MAAM;gBACN,MAAM;gBACN,cAAc,4RACZ,KAAK,IAAI,CAAC,EAAE,CAAC,UAAU,EACvB,gSAAuB;oBAAC;oBAAa;iBAAE;YAE3C;QACF;IACF;AACF"}},
    {"offset": {"line": 4327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4332, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/core.js"],"sourcesContent":["/**\n * @typedef {import('remark-rehype').Options} RemarkRehypeOptions\n * @typedef {import('unified').PluggableList} PluggableList\n * @typedef {import('unified').Processor} Processor\n * @typedef {import('./plugin/rehype-recma.js').Options} RehypeRecmaOptions\n * @typedef {import('./plugin/recma-document.js').RecmaDocumentOptions} RecmaDocumentOptions\n * @typedef {import('./plugin/recma-stringify.js').RecmaStringifyOptions} RecmaStringifyOptions\n * @typedef {import('./plugin/recma-jsx-rewrite.js').RecmaJsxRewriteOptions} RecmaJsxRewriteOptions\n */\n\n/**\n * @typedef BaseProcessorOptions\n *   Base configuration.\n * @property {boolean | null | undefined} [jsx=false]\n *   Whether to keep JSX.\n * @property {'mdx' | 'md' | null | undefined} [format='mdx']\n *   Format of the files to be processed.\n * @property {'function-body' | 'program'} [outputFormat='program']\n *   Whether to compile to a whole program or a function body..\n * @property {Array<string> | null | undefined} [mdExtensions]\n *   Extensions (with `.`) for markdown.\n * @property {Array<string> | null | undefined} [mdxExtensions]\n *   Extensions (with `.`) for MDX.\n * @property {PluggableList | null | undefined} [recmaPlugins]\n *   List of recma (esast, JavaScript) plugins.\n * @property {PluggableList | null | undefined} [remarkPlugins]\n *   List of remark (mdast, markdown) plugins.\n * @property {PluggableList | null | undefined} [rehypePlugins]\n *   List of rehype (hast, HTML) plugins.\n * @property {RemarkRehypeOptions | null | undefined} [remarkRehypeOptions]\n *   Options to pass through to `remark-rehype`.\n *\n * @typedef {Omit<RehypeRecmaOptions & RecmaDocumentOptions & RecmaStringifyOptions & RecmaJsxRewriteOptions, 'outputFormat'>} PluginOptions\n *   Configuration for internal plugins.\n *\n * @typedef {BaseProcessorOptions & PluginOptions} ProcessorOptions\n *   Configuration for processor.\n */\n\nimport {unified} from 'unified'\nimport remarkMdx from 'remark-mdx'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport {recmaJsxBuild} from './plugin/recma-jsx-build.js'\nimport {recmaDocument} from './plugin/recma-document.js'\nimport {recmaJsxRewrite} from './plugin/recma-jsx-rewrite.js'\nimport {recmaStringify} from './plugin/recma-stringify.js'\nimport {rehypeRecma} from './plugin/rehype-recma.js'\nimport {rehypeRemoveRaw} from './plugin/rehype-remove-raw.js'\nimport {remarkMarkAndUnravel} from './plugin/remark-mark-and-unravel.js'\nimport {nodeTypes} from './node-types.js'\nimport {development as defaultDevelopment} from './condition.js'\n\nconst removedOptions = [\n  'filepath',\n  'compilers',\n  'hastPlugins',\n  'mdPlugins',\n  'skipExport',\n  'wrapExport'\n]\n\n/**\n * Pipeline to:\n *\n * 1. Parse MDX (serialized markdown with embedded JSX, ESM, and  expressions)\n * 2. Transform through remark (mdast), rehype (hast), and recma (esast)\n * 3. Serialize as JavaScript\n *\n * @param {ProcessorOptions | null | undefined} [options]\n *   Configuration.\n * @return {Processor}\n *   Processor.\n */\nexport function createProcessor(options) {\n  const {\n    development,\n    jsx,\n    format,\n    outputFormat,\n    providerImportSource,\n    recmaPlugins,\n    rehypePlugins,\n    remarkPlugins,\n    remarkRehypeOptions,\n    elementAttributeNameCase,\n    stylePropertyNameCase,\n    SourceMapGenerator,\n    ...rest\n  } = options || {}\n  const dev =\n    development === null || development === undefined\n      ? defaultDevelopment\n      : development\n  let index = -1\n\n  while (++index < removedOptions.length) {\n    const key = removedOptions[index]\n    if (options && key in options) {\n      throw new Error(\n        '`options.' +\n          key +\n          '` is no longer supported. Please see <https://mdxjs.com/migrating/v2/> for more information'\n      )\n    }\n  }\n\n  // @ts-expect-error runtime exception for disallowed field here, which is\n  // allowed in `compile`.\n  if (format === 'detect') {\n    throw new Error(\n      \"Incorrect `format: 'detect'`: `createProcessor` can support either `md` or `mdx`; it does not support detecting the format\"\n    )\n  }\n\n  const pipeline = unified().use(remarkParse)\n\n  if (format !== 'md') {\n    pipeline.use(remarkMdx)\n  }\n\n  const extraNodeTypes = remarkRehypeOptions\n    ? /* c8 ignore next */\n      remarkRehypeOptions.passThrough || []\n    : []\n\n  pipeline\n    .use(remarkMarkAndUnravel)\n    .use(remarkPlugins || [])\n    .use(remarkRehype, {\n      ...remarkRehypeOptions,\n      allowDangerousHtml: true,\n      passThrough: [...extraNodeTypes, ...nodeTypes]\n    })\n    .use(rehypePlugins || [])\n\n  if (format === 'md') {\n    pipeline.use(rehypeRemoveRaw)\n  }\n\n  pipeline\n    .use(rehypeRecma, {elementAttributeNameCase, stylePropertyNameCase})\n    .use(recmaDocument, {...rest, outputFormat})\n    .use(recmaJsxRewrite, {\n      development: dev,\n      providerImportSource,\n      outputFormat\n    })\n\n  if (!jsx) {\n    pipeline.use(recmaJsxBuild, {development: dev, outputFormat})\n  }\n\n  pipeline.use(recmaStringify, {SourceMapGenerator}).use(recmaPlugins || [])\n\n  return pipeline\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBD,MAAM,iBAAiB;IACrB;IACA;IACA;IACA;IACA;IACA;CACD;AAcM,SAAS,gBAAgB,OAAO;IACrC,MAAM,EACJ,WAAW,EACX,GAAG,EACH,MAAM,EACN,YAAY,EACZ,oBAAoB,EACpB,YAAY,EACZ,aAAa,EACb,aAAa,EACb,mBAAmB,EACnB,wBAAwB,EACxB,qBAAqB,EACrB,kBAAkB,EAClB,GAAG,MACJ,GAAG,WAAW,CAAC;IAChB,MAAM,MACJ,gBAAgB,QAAQ,gBAAgB,4OAEpC;IACN,IAAI,QAAQ,CAAC;IAEb,MAAO,EAAE,QAAQ,eAAe,MAAM,CAAE;QACtC,MAAM,MAAM,cAAc,CAAC,MAAM;QACjC,IAAI,WAAW,OAAO,SAAS;YAC7B,MAAM,IAAI,MACR,cACE,MACA;QAEN;IACF;IAEA,yEAAyE;IACzE,wBAAwB;IACxB,IAAI,WAAW,UAAU;QACvB,MAAM,IAAI,MACR;IAEJ;IAEA,MAAM,WAAW,4LAAU,GAAG;IAE9B,IAAI,WAAW,MAAM;QACnB,SAAS,GAAG;IACd;IAEA,MAAM,iBAAiB,sBACnB,kBAAkB,GAClB,oBAAoB,WAAW,IAAI,EAAE,GACrC,EAAE;IAEN,SACG,GAAG,0QACH,GAAG,CAAC,iBAAiB,EAAE,EACvB,GAAG,8MAAe;QACjB,GAAG,mBAAmB;QACtB,oBAAoB;QACpB,aAAa;eAAI;;SAA6B;IAChD,GACC,GAAG,CAAC,iBAAiB,EAAE;IAE1B,IAAI,WAAW,MAAM;QACnB,SAAS,GAAG;IACd;IAEA,SACG,GAAG,gPAAc;QAAC;QAA0B;IAAqB,GACjE,GAAG,oPAAgB;QAAC,GAAG,IAAI;QAAE;IAAY,GACzC,GAAG,4PAAkB;QACpB,aAAa;QACb;QACA;IACF;IAEF,IAAI,CAAC,KAAK;QACR,SAAS,GAAG,wPAAgB;YAAC,aAAa;YAAK;QAAY;IAC7D;IAEA,SAAS,GAAG,sPAAiB;QAAC;IAAkB,GAAG,GAAG,CAAC,gBAAgB,EAAE;IAEzE,OAAO;AACT"}},
    {"offset": {"line": 4458, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4463, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/compile.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('./core.js').PluginOptions} PluginOptions\n * @typedef {import('./core.js').BaseProcessorOptions} BaseProcessorOptions\n */\n\n/**\n * @typedef {Omit<BaseProcessorOptions, 'format'>} CoreProcessorOptions\n *   Core configuration.\n *\n * @typedef ExtraOptions\n *   Extra configuration.\n * @property {'detect' | 'mdx' | 'md' | null | undefined} [format='detect']\n *   Format of `file`.\n *\n * @typedef {CoreProcessorOptions & PluginOptions & ExtraOptions} CompileOptions\n *   Configuration.\n */\n\nimport {createProcessor} from './core.js'\nimport {resolveFileAndOptions} from './util/resolve-file-and-options.js'\n\n/**\n * Compile MDX to JS.\n *\n * @param {VFileCompatible} vfileCompatible\n *   MDX document to parse (`string`, `Buffer`, `vfile`, anything that can be\n *   given to `vfile`).\n * @param {CompileOptions | null | undefined} [compileOptions]\n *   Compile configuration.\n * @return {Promise<VFile>}\n *   File.\n */\nexport function compile(vfileCompatible, compileOptions) {\n  const {file, options} = resolveFileAndOptions(vfileCompatible, compileOptions)\n  return createProcessor(options).process(file)\n}\n\n/**\n * Synchronously compile MDX to JS.\n *\n * @param {VFileCompatible} vfileCompatible\n *   MDX document to parse (`string`, `Buffer`, `vfile`, anything that can be\n *   given to `vfile`).\n * @param {CompileOptions | null | undefined} [compileOptions]\n *   Compile configuration.\n * @return {VFile}\n *   File.\n */\nexport function compileSync(vfileCompatible, compileOptions) {\n  const {file, options} = resolveFileAndOptions(vfileCompatible, compileOptions)\n  return createProcessor(options).processSync(file)\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;;;;;;;;;;CAWC;;;;;;;;;AAgBM,SAAS,QAAQ,eAAe,EAAE,cAAc;IACrD,MAAM,EAAC,IAAI,EAAE,OAAO,EAAC,GAAG,wQAAsB,iBAAiB;IAC/D,OAAO,6NAAgB,SAAS,OAAO,CAAC;AAC1C;AAaO,SAAS,YAAY,eAAe,EAAE,cAAc;IACzD,MAAM,EAAC,IAAI,EAAE,OAAO,EAAC,GAAG,wQAAsB,iBAAiB;IAC/D,OAAO,6NAAgB,SAAS,WAAW,CAAC;AAC9C"}},
    {"offset": {"line": 4496, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4501, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/lib/evaluate.js"],"sourcesContent":["/**\n * @typedef {import('mdx/types.js').MDXModule} ExportMap\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('./util/resolve-evaluate-options.js').EvaluateOptions} EvaluateOptions\n */\n\nimport {compile, compileSync} from './compile.js'\nimport {run, runSync} from './run.js'\nimport {resolveEvaluateOptions} from './util/resolve-evaluate-options.js'\n\n/**\n * Evaluate MDX.\n *\n * @param {VFileCompatible} vfileCompatible\n *   MDX document to parse (`string`, `Buffer`, `vfile`, anything that can be\n *   given to `vfile`).\n * @param {EvaluateOptions} evaluateOptions\n *   Configuration for evaluation.\n * @return {Promise<ExportMap>}\n *   Export map.\n */\nexport async function evaluate(vfileCompatible, evaluateOptions) {\n  const {compiletime, runtime} = resolveEvaluateOptions(evaluateOptions)\n  return run(await compile(vfileCompatible, compiletime), runtime)\n}\n\n/**\n * Synchronously evaluate MDX.\n *\n * @param {VFileCompatible} vfileCompatible\n *   MDX document to parse (`string`, `Buffer`, `vfile`, anything that can be\n *   given to `vfile`).\n * @param {EvaluateOptions} evaluateOptions\n *   Configuration for evaluation.\n * @return {ExportMap}\n *   Export map.\n */\nexport function evaluateSync(vfileCompatible, evaluateOptions) {\n  const {compiletime, runtime} = resolveEvaluateOptions(evaluateOptions)\n  return runSync(compileSync(vfileCompatible, compiletime), runtime)\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;;;;AAiBM,eAAe,SAAS,eAAe,EAAE,eAAe;IAC7D,MAAM,EAAC,WAAW,EAAE,OAAO,EAAC,GAAG,sQAAuB;IACtD,OAAO,gNAAI,MAAM,wNAAQ,iBAAiB,cAAc;AAC1D;AAaO,SAAS,aAAa,eAAe,EAAE,eAAe;IAC3D,MAAM,EAAC,WAAW,EAAE,OAAO,EAAC,GAAG,sQAAuB;IACtD,OAAO,oNAAQ,4NAAY,iBAAiB,cAAc;AAC5D"}},
    {"offset": {"line": 4524, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4529, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/@mdx-js+mdx@2.3.0/node_modules/@mdx-js/mdx/index.js"],"sourcesContent":["/**\n * @typedef {import('./lib/core.js').ProcessorOptions} ProcessorOptions\n * @typedef {import('./lib/compile.js').CompileOptions} CompileOptions\n * @typedef {import('./lib/evaluate.js').EvaluateOptions} EvaluateOptions\n */\n\nexport {createProcessor} from './lib/core.js'\nexport {compile, compileSync} from './lib/compile.js'\nexport {evaluate, evaluateSync} from './lib/evaluate.js'\nexport {run, runSync} from './lib/run.js'\nexport {nodeTypes} from './lib/node-types.js'\n"],"names":[],"mappings":"AAAA;;;;CAIC"}},
    {"offset": {"line": 4554, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}